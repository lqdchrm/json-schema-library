{
  "version": 3,
  "sources": ["../node_modules/deepmerge/dist/cjs.js", "../node_modules/@sagold/json-pointer/dist/jsonPointer.js", "../node_modules/ebnf/dist/TokenError.js", "../node_modules/ebnf/dist/Parser.js", "../node_modules/ebnf/dist/Grammars/W3CEBNF.js", "../node_modules/valid-url/index.js", "../node_modules/fast-deep-equal/index.js", "module/lib/config/strings.js", "module/lib/utils/render.js", "module/lib/utils/__.js", "module/lib/utils/createCustomError.js", "module/lib/getTypeOf.js", "module/lib/types.js", "module/lib/utils/filter.js", "module/lib/utils/flattenArray.js", "module/lib/config/settings.js", "module/lib/resolveOneOf.strict.js", "module/lib/utils/copy.js", "module/lib/utils/merge.js", "module/lib/resolveAllOf.js", "module/lib/resolveOneOf.fuzzy.js", "module/lib/resolveRef.strict.js", "module/lib/resolveRef.merge.js", "module/lib/getSchema.js", "module/lib/draft/index.js", "module/lib/addRemoteSchema.js", "module/lib/eachSchema.js", "module/lib/schema/getTypeDefs.js", "../node_modules/@sagold/json-query/dist/module/lib/parser/index.js", "../node_modules/@sagold/json-query/dist/module/lib/parser/jsonQueryGrammar.js", "../node_modules/@sagold/json-query/dist/module/lib/interpreter/nodes.js", "../node_modules/@sagold/json-query/dist/module/lib/interpreter/index.js", "../node_modules/@sagold/json-query/dist/module/lib/get.js", "../node_modules/@sagold/json-query/dist/module/lib/split.js", "../node_modules/@sagold/json-query/dist/module/lib/set.js", "../node_modules/@sagold/json-query/dist/module/lib/remove.js", "module/lib/schema/types.js", "module/lib/schema/getTypeId.js", "module/lib/compile/joinScope.js", "module/lib/compile/getRef.js", "module/lib/compile/splitRef.js", "module/lib/draft06/compile/index.js", "module/lib/each.js", "module/lib/validation/errors.js", "module/lib/validation/format.js", "module/lib/utils/isEmpty.js", "module/lib/getTemplate.js", "module/lib/isValid.js", "module/lib/utils/deepCompare.js", "module/lib/utils/punycode.ucs2decode.js", "module/lib/validation/keyword.js", "module/lib/draft06/validation/keyword.js", "module/lib/resolveAnyOf.js", "module/lib/createSchemaOf.js", "module/lib/getChildSchemaSelection.js", "module/lib/step.js", "module/lib/draft06/validation/type.js", "module/lib/validate.js", "module/lib/draft07/index.js", "module/lib/jsoneditor/index.js", "module/lib/SchemaService.js", "module/lib/validateAsync.js", "module/lib/compile/index.js", "module/lib/compileSchema.js", "module/lib/validation/type.js", "module/lib/draft04/index.js", "module/lib/draft06/index.js", "module/index.js"],
  "sourcesContent": ["'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n", "!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"jsonPointer\",[],t):\"object\"==typeof exports?exports.jsonPointer=t():e.jsonPointer=t()}(\"undefined\"!=typeof self?self:this,(()=>(()=>{\"use strict\";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},t={};function n(e){return\"#\"===e||\"\"===e||Array.isArray(e)&&0===e.length||!1}e.r(t),e.d(t,{default:()=>x,get:()=>c,isRoot:()=>n,join:()=>_,remove:()=>v,removeUndefinedItems:()=>j,set:()=>y,split:()=>s});const r=/~1/g,o=/~0/g,i=/\\/+/g,l=/(^[#/]*|\\/+$)/g;function u(e){return e.replace(r,\"/\").replace(o,\"~\")}function f(e){return u(decodeURIComponent(e))}function s(e){if(null==e||\"string\"!=typeof e||n(e))return Array.isArray(e)?e:[];const t=e.indexOf(\"#\")>=0?f:u,r=(e=(e=e.replace(i,\"/\")).replace(l,\"\")).split(\"/\");for(let e=0,n=r.length;e<n;e+=1)r[e]=t(r[e]);return r}function c(e,t,r){if(null==t||null==e)return r;if(n(t))return e;const o=p(e,s(t));return void 0===o?r:o}function p(e,t){const n=t.shift();if(void 0!==e)return void 0!==n?p(e[n],t):e}const a=/^\\[.*\\]$/,d=/^\\[(.+)\\]$/;function g(e,t){return\"__proto__\"===e||\"constructor\"==e&&t.length>0&&\"prototype\"==t[0]}function y(e,t,n){if(null==t)return e;const r=s(t);if(0===r.length)return e;null==e&&(e=a.test(r[0])?[]:{});let o,i,l=e;for(;r.length>1;)o=r.shift(),i=a.test(r[0]),g(o,r)||(l=m(l,o,i));return o=r.pop(),h(l,o,n),e}function h(e,t,n){let r;const o=t.match(d);\"[]\"===t&&Array.isArray(e)?e.push(n):o?(r=o.pop(),e[r]=n):e[t]=n}function m(e,t,n){if(null!=e[t])return e[t];const r=n?[]:{};return h(e,t,r),r}function j(e){let t=0,n=0;for(;t+n<e.length;)void 0===e[t+n]&&(n+=1),e[t]=e[t+n],t+=1;return e.length=e.length-n,e}function v(e,t,n){const r=s(t),o=r.pop(),i=c(e,r);return i&&delete i[o],Array.isArray(i)&&!0!==n&&j(i),e}const b=/\\/+/g,A=/~/g,P=/\\//g;function O(e,t){if(0===e.length)return t?\"#\":\"\";for(let n=0,r=e.length;n<r;n+=1)e[n]=e[n].replace(A,\"~0\").replace(P,\"~1\"),t&&(e[n]=encodeURIComponent(e[n]));return((t?\"#/\":\"/\")+e.join(\"/\")).replace(b,\"/\")}function _(e,...t){const n=[];if(Array.isArray(e))return O(e,!0===arguments[1]);const r=arguments[arguments.length-1],o=\"boolean\"==typeof r?r:e&&\"#\"===e[0];for(let e=0,t=arguments.length;e<t;e+=1)n.push.apply(n,s(arguments[e]));const i=[];for(let e=0,t=n.length;e<t;e+=1)if(\"..\"===n[e]){if(0===i.length)return o?\"#\":\"\";i.pop()}else i.push(n[e]);return O(i,o)}const x={get:c,set:y,remove:v,join:_,split:s,splitLast:function(e){const t=s(e);if(0===t.length)return\"string\"==typeof e&&\"#\"===e[0]?[\"#\",t[0]]:[\"\",void 0];if(1===t.length)return\"#\"===e[0]?[\"#\",t[0]]:[\"\",t[0]];const n=t.pop();return[_(t,\"#\"===e[0]),n]},isRoot:n,removeUndefinedItems:j};return t})()));", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TokenError = void 0;\nclass TokenError extends Error {\n    constructor(message, token) {\n        super(message);\n        this.message = message;\n        this.token = token;\n        if (token && token.errors)\n            token.errors.push(this);\n        else\n            throw this;\n    }\n    inspect() {\n        return 'SyntaxError: ' + this.message;\n    }\n}\nexports.TokenError = TokenError;\n//# sourceMappingURL=TokenError.js.map", "\"use strict\";\n// https://www.ics.uci.edu/~pattis/ICS-33/lectures/ebnf.pdf\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = exports.findRuleByName = exports.parseRuleName = exports.escapeRegExp = exports.readToken = void 0;\nconst UPPER_SNAKE_RE = /^[A-Z0-9_]+$/;\nconst decorationRE = /(\\?|\\+|\\*)$/;\nconst preDecorationRE = /^(@|&|!)/;\nconst WS_RULE = 'WS';\nconst TokenError_1 = require(\"./TokenError\");\nfunction readToken(txt, expr) {\n    let result = expr.exec(txt);\n    if (result && result.index == 0) {\n        if (result[0].length == 0 && expr.source.length > 0)\n            return null;\n        return {\n            type: null,\n            text: result[0],\n            rest: txt.substr(result[0].length),\n            start: 0,\n            end: result[0].length - 1,\n            fullText: result[0],\n            errors: [],\n            children: [],\n            parent: null\n        };\n    }\n    return null;\n}\nexports.readToken = readToken;\nfunction escapeRegExp(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\nexports.escapeRegExp = escapeRegExp;\nfunction fixRest(token) {\n    token.rest = '';\n    token.children && token.children.forEach(c => fixRest(c));\n}\nfunction fixPositions(token, start) {\n    token.start += start;\n    token.end += start;\n    token.children && token.children.forEach(c => fixPositions(c, token.start));\n}\nfunction agregateErrors(errors, token) {\n    if (token.errors && token.errors.length)\n        token.errors.forEach(err => errors.push(err));\n    token.children && token.children.forEach(tok => agregateErrors(errors, tok));\n}\nfunction parseRuleName(name) {\n    let postDecoration = decorationRE.exec(name);\n    let preDecoration = preDecorationRE.exec(name);\n    let postDecorationText = (postDecoration && postDecoration[0]) || '';\n    let preDecorationText = (preDecoration && preDecoration[0]) || '';\n    let out = {\n        raw: name,\n        name: name.replace(decorationRE, '').replace(preDecorationRE, ''),\n        isOptional: postDecorationText == '?' || postDecorationText == '*',\n        allowRepetition: postDecorationText == '+' || postDecorationText == '*',\n        atLeastOne: postDecorationText == '+',\n        lookupPositive: preDecorationText == '&',\n        lookupNegative: preDecorationText == '!',\n        pinned: preDecorationText == '@',\n        lookup: false,\n        isLiteral: false\n    };\n    out.isLiteral = out.name[0] == \"'\" || out.name[0] == '\"';\n    out.lookup = out.lookupNegative || out.lookupPositive;\n    return out;\n}\nexports.parseRuleName = parseRuleName;\nfunction findRuleByName(name, parser) {\n    let parsed = parseRuleName(name);\n    return parser.cachedRules[parsed.name] || null;\n}\nexports.findRuleByName = findRuleByName;\n/// Removes all the nodes starting with 'RULE_'\nfunction stripRules(token, re) {\n    if (token.children) {\n        let localRules = token.children.filter(x => x.type && re.test(x.type));\n        for (let i = 0; i < localRules.length; i++) {\n            let indexOnChildren = token.children.indexOf(localRules[i]);\n            if (indexOnChildren != -1) {\n                token.children.splice(indexOnChildren, 1);\n            }\n        }\n        token.children.forEach(c => stripRules(c, re));\n    }\n}\nconst ignoreMissingRules = ['EOF'];\nclass Parser {\n    constructor(grammarRules, options) {\n        this.grammarRules = grammarRules;\n        this.options = options;\n        this.cachedRules = {};\n        this.debug = options ? options.debug === true : false;\n        let errors = [];\n        let neededRules = [];\n        grammarRules.forEach(rule => {\n            let parsedName = parseRuleName(rule.name);\n            if (parsedName.name in this.cachedRules) {\n                errors.push('Duplicated rule ' + parsedName.name);\n                return;\n            }\n            else {\n                this.cachedRules[parsedName.name] = rule;\n            }\n            if (!rule.bnf || !rule.bnf.length) {\n                let error = 'Missing rule content, rule: ' + rule.name;\n                if (errors.indexOf(error) == -1)\n                    errors.push(error);\n            }\n            else {\n                rule.bnf.forEach(options => {\n                    if (typeof options[0] === 'string') {\n                        let parsed = parseRuleName(options[0]);\n                        if (parsed.name == rule.name) {\n                            let error = 'Left recursion is not allowed, rule: ' + rule.name;\n                            if (errors.indexOf(error) == -1)\n                                errors.push(error);\n                        }\n                    }\n                    options.forEach(option => {\n                        if (typeof option == 'string') {\n                            let name = parseRuleName(option);\n                            if (!name.isLiteral &&\n                                neededRules.indexOf(name.name) == -1 &&\n                                ignoreMissingRules.indexOf(name.name) == -1)\n                                neededRules.push(name.name);\n                        }\n                    });\n                });\n            }\n            if (WS_RULE == rule.name)\n                rule.implicitWs = false;\n            if (rule.implicitWs) {\n                if (neededRules.indexOf(WS_RULE) == -1)\n                    neededRules.push(WS_RULE);\n            }\n            if (rule.recover) {\n                if (neededRules.indexOf(rule.recover) == -1)\n                    neededRules.push(rule.recover);\n            }\n        });\n        neededRules.forEach(ruleName => {\n            if (!(ruleName in this.cachedRules)) {\n                errors.push('Missing rule ' + ruleName);\n            }\n        });\n        if (errors.length)\n            throw new Error(errors.join('\\n'));\n    }\n    getAST(txt, target) {\n        if (!target) {\n            target = this.grammarRules.filter(x => !x.fragment && x.name.indexOf('%') != 0)[0].name;\n        }\n        let result = this.parse(txt, target);\n        if (result) {\n            agregateErrors(result.errors, result);\n            fixPositions(result, 0);\n            // REMOVE ALL THE TAGS MATCHING /^%/\n            stripRules(result, /^%/);\n            if (!this.options || !this.options.keepUpperRules)\n                stripRules(result, UPPER_SNAKE_RE);\n            let rest = result.rest;\n            if (rest) {\n                new TokenError_1.TokenError('Unexpected end of input: \\n' + rest, result);\n            }\n            fixRest(result);\n            result.rest = rest;\n        }\n        return result;\n    }\n    emitSource() {\n        return 'CANNOT EMIT SOURCE FROM BASE Parser';\n    }\n    parse(txt, target, recursion = 0) {\n        let out = null;\n        let type = parseRuleName(target);\n        let expr;\n        let printable = this.debug && /*!isLiteral &*/ !UPPER_SNAKE_RE.test(type.name);\n        printable &&\n            console.log(new Array(recursion).join('\u2502  ') + 'Trying to get ' + target + ' from ' + JSON.stringify(txt.split('\\n')[0]));\n        let realType = type.name;\n        let targetLex = findRuleByName(type.name, this);\n        if (type.name == 'EOF') {\n            if (txt.length) {\n                return null;\n            }\n            else if (txt.length == 0) {\n                return {\n                    type: 'EOF',\n                    text: '',\n                    rest: '',\n                    start: 0,\n                    end: 0,\n                    fullText: '',\n                    errors: [],\n                    children: [],\n                    parent: null\n                };\n            }\n        }\n        try {\n            if (!targetLex && type.isLiteral) {\n                // tslint:disable-next-line: no-eval\n                let src = eval(type.name);\n                if (src === '') {\n                    return {\n                        type: '%%EMPTY%%',\n                        text: '',\n                        rest: txt,\n                        start: 0,\n                        end: 0,\n                        fullText: '',\n                        errors: [],\n                        children: [],\n                        parent: null\n                    };\n                }\n                expr = new RegExp(escapeRegExp(src));\n                realType = null;\n            }\n        }\n        catch (e) {\n            if (e instanceof ReferenceError) {\n                console.error(e);\n            }\n            return null;\n        }\n        if (expr) {\n            let result = readToken(txt, expr);\n            if (result) {\n                result.type = realType;\n                return result;\n            }\n        }\n        else {\n            let options = targetLex.bnf;\n            if (options instanceof Array) {\n                options.forEach(phases => {\n                    if (out)\n                        return;\n                    let pinned = null;\n                    let tmp = {\n                        type: type.name,\n                        text: '',\n                        children: [],\n                        end: 0,\n                        errors: [],\n                        fullText: '',\n                        parent: null,\n                        start: 0,\n                        rest: txt\n                    };\n                    if (targetLex.fragment)\n                        tmp.fragment = true;\n                    let tmpTxt = txt;\n                    let position = 0;\n                    let allOptional = phases.length > 0;\n                    let foundSomething = false;\n                    for (let i = 0; i < phases.length; i++) {\n                        if (typeof phases[i] == 'string') {\n                            let localTarget = parseRuleName(phases[i]);\n                            allOptional = allOptional && localTarget.isOptional;\n                            let got;\n                            let foundAtLeastOne = false;\n                            do {\n                                got = null;\n                                if (targetLex.implicitWs) {\n                                    got = this.parse(tmpTxt, localTarget.name, recursion + 1);\n                                    if (!got) {\n                                        let WS;\n                                        do {\n                                            WS = this.parse(tmpTxt, WS_RULE, recursion + 1);\n                                            if (WS) {\n                                                tmp.text = tmp.text + WS.text;\n                                                tmp.end = tmp.text.length;\n                                                WS.parent = tmp;\n                                                tmp.children.push(WS);\n                                                tmpTxt = tmpTxt.substr(WS.text.length);\n                                                position += WS.text.length;\n                                            }\n                                            else {\n                                                break;\n                                            }\n                                        } while (WS && WS.text.length);\n                                    }\n                                }\n                                got = got || this.parse(tmpTxt, localTarget.name, recursion + 1);\n                                // rule ::= \"true\" ![a-zA-Z]\n                                // negative lookup, if it does not match, we should continue\n                                if (localTarget.lookupNegative) {\n                                    if (got)\n                                        return /* cancel this path */;\n                                    break;\n                                }\n                                if (localTarget.lookupPositive) {\n                                    if (!got)\n                                        return;\n                                }\n                                if (!got) {\n                                    if (localTarget.isOptional)\n                                        break;\n                                    if (localTarget.atLeastOne && foundAtLeastOne)\n                                        break;\n                                }\n                                if (got && targetLex.pinned == i + 1) {\n                                    pinned = got;\n                                    printable && console.log(new Array(recursion + 1).join('\u2502  ') + '\u2514\u2500 ' + got.type + ' PINNED');\n                                }\n                                if (!got)\n                                    got = this.parseRecovery(targetLex, tmpTxt, recursion + 1);\n                                if (!got) {\n                                    if (pinned) {\n                                        out = tmp;\n                                        got = {\n                                            type: 'SyntaxError',\n                                            text: tmpTxt,\n                                            children: [],\n                                            end: tmpTxt.length,\n                                            errors: [],\n                                            fullText: '',\n                                            parent: null,\n                                            start: 0,\n                                            rest: ''\n                                        };\n                                        if (tmpTxt.length) {\n                                            new TokenError_1.TokenError(`Unexpected end of input. Expecting ${localTarget.name} Got: ${tmpTxt}`, got);\n                                        }\n                                        else {\n                                            new TokenError_1.TokenError(`Unexpected end of input. Missing ${localTarget.name}`, got);\n                                        }\n                                        printable &&\n                                            console.log(new Array(recursion + 1).join('\u2502  ') + '\u2514\u2500 ' + got.type + ' ' + JSON.stringify(got.text));\n                                    }\n                                    else {\n                                        return;\n                                    }\n                                }\n                                foundAtLeastOne = true;\n                                foundSomething = true;\n                                if (got.type == '%%EMPTY%%') {\n                                    break;\n                                }\n                                got.start += position;\n                                got.end += position;\n                                if (!localTarget.lookupPositive && got.type) {\n                                    if (got.fragment) {\n                                        got.children &&\n                                            got.children.forEach(x => {\n                                                x.start += position;\n                                                x.end += position;\n                                                x.parent = tmp;\n                                                tmp.children.push(x);\n                                            });\n                                    }\n                                    else {\n                                        got.parent = tmp;\n                                        tmp.children.push(got);\n                                    }\n                                }\n                                if (localTarget.lookup)\n                                    got.lookup = true;\n                                printable &&\n                                    console.log(new Array(recursion + 1).join('\u2502  ') + '\u2514\u2500 ' + got.type + ' ' + JSON.stringify(got.text));\n                                // Eat it from the input stream, only if it is not a lookup\n                                if (!localTarget.lookup && !got.lookup) {\n                                    tmp.text = tmp.text + got.text;\n                                    tmp.end = tmp.text.length;\n                                    tmpTxt = tmpTxt.substr(got.text.length);\n                                    position += got.text.length;\n                                }\n                                tmp.rest = tmpTxt;\n                            } while (got && localTarget.allowRepetition && tmpTxt.length && !got.lookup);\n                        } /* IS A REGEXP */\n                        else {\n                            let got = readToken(tmpTxt, phases[i]);\n                            if (!got) {\n                                return;\n                            }\n                            printable &&\n                                console.log(new Array(recursion + 1).join('\u2502  ') + '\u2514> ' + JSON.stringify(got.text) + phases[i].source);\n                            foundSomething = true;\n                            got.start += position;\n                            got.end += position;\n                            tmp.text = tmp.text + got.text;\n                            tmp.end = tmp.text.length;\n                            tmpTxt = tmpTxt.substr(got.text.length);\n                            position += got.text.length;\n                            tmp.rest = tmpTxt;\n                        }\n                    }\n                    if (foundSomething) {\n                        out = tmp;\n                        printable &&\n                            console.log(new Array(recursion).join('\u2502  ') + '\u251C<\u2500\u2534< PUSHING ' + out.type + ' ' + JSON.stringify(out.text));\n                    }\n                });\n            }\n            if (out && targetLex.simplifyWhenOneChildren && out.children.length == 1) {\n                out = out.children[0];\n            }\n        }\n        if (!out) {\n            printable && console.log(target + ' NOT RESOLVED FROM ' + txt);\n        }\n        return out;\n    }\n    parseRecovery(recoverableToken, tmpTxt, recursion) {\n        if (recoverableToken.recover && tmpTxt.length) {\n            let printable = this.debug;\n            printable &&\n                console.log(new Array(recursion + 1).join('\u2502  ') +\n                    'Trying to recover until token ' +\n                    recoverableToken.recover +\n                    ' from ' +\n                    JSON.stringify(tmpTxt.split('\\n')[0] + tmpTxt.split('\\n')[1]));\n            let tmp = {\n                type: 'SyntaxError',\n                text: '',\n                children: [],\n                end: 0,\n                errors: [],\n                fullText: '',\n                parent: null,\n                start: 0,\n                rest: ''\n            };\n            let got;\n            do {\n                got = this.parse(tmpTxt, recoverableToken.recover, recursion + 1);\n                if (got) {\n                    new TokenError_1.TokenError('Unexpected input: \"' + tmp.text + `\" Expecting: ${recoverableToken.name}`, tmp);\n                    break;\n                }\n                else {\n                    tmp.text = tmp.text + tmpTxt[0];\n                    tmp.end = tmp.text.length;\n                    tmpTxt = tmpTxt.substr(1);\n                }\n            } while (!got && tmpTxt.length > 0);\n            if (tmp.text.length > 0 && got) {\n                printable && console.log(new Array(recursion + 1).join('\u2502  ') + 'Recovered text: ' + JSON.stringify(tmp.text));\n                return tmp;\n            }\n        }\n        return null;\n    }\n}\nexports.Parser = Parser;\nexports.default = Parser;\n//# sourceMappingURL=Parser.js.map", "\"use strict\";\n// https://www.w3.org/TR/REC-xml/#NT-Name\n// http://www.bottlecaps.de/rr/ui\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Grammar\t::=\tProduction*\n// Production\t::=\tNCName '::=' Choice\n// NCName\t::=\t[http://www.w3.org/TR/xml-names/#NT-NCName]\n// Choice\t::=\tSequenceOrDifference ( '|' SequenceOrDifference )*\n// SequenceOrDifference\t::=\t(Item ( '-' Item | Item* ))?\n// Item\t::=\tPrimary ( '?' | '*' | '+' )?\n// Primary\t::=\tNCName | StringLiteral | CharCode | CharClass | '(' Choice ')'\n// StringLiteral\t::=\t'\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n// CharCode\t::=\t'#x' [0-9a-fA-F]+\n// CharClass\t::=\t'[' '^'? ( RULE_Char | CharCode | CharRange | CharCodeRange )+ ']'\n// RULE_Char\t::=\t[http://www.w3.org/TR/xml#NT-RULE_Char]\n// CharRange\t::=\tRULE_Char '-' ( RULE_Char - ']' )\n// CharCodeRange\t::=\tCharCode '-' CharCode\n// RULE_WHITESPACE\t::=\tRULE_S | Comment\n// RULE_S\t::=\t#x9 | #xA | #xD | #x20\n// Comment\t::=\t'/*' ( [^*] | '*'+ [^*/] )* '*'* '*/'\nconst Parser_1 = require(\"../Parser\");\nvar BNF;\n(function (BNF) {\n    BNF.RULES = [\n        {\n            name: 'Grammar',\n            bnf: [['RULE_S*', '%Atomic*', 'EOF']]\n        },\n        {\n            name: '%Atomic',\n            bnf: [['Production', 'RULE_S*']],\n            fragment: true\n        },\n        {\n            name: 'Production',\n            bnf: [['NCName', 'RULE_S*', '\"::=\"', 'RULE_WHITESPACE*', 'Choice', 'RULE_WHITESPACE*', 'RULE_EOL+', 'RULE_S*']]\n        },\n        {\n            name: 'NCName',\n            bnf: [[/[a-zA-Z][a-zA-Z_0-9]*/]]\n        },\n        {\n            name: 'Choice',\n            bnf: [['SequenceOrDifference', '%_Choice_1*']],\n            fragment: true\n        },\n        {\n            name: '%_Choice_1',\n            bnf: [['RULE_WHITESPACE*', '\"|\"', 'RULE_WHITESPACE*', 'SequenceOrDifference']],\n            fragment: true\n        },\n        {\n            name: 'SequenceOrDifference',\n            bnf: [['Item', 'RULE_WHITESPACE*', '%_Item_1?']]\n        },\n        {\n            name: '%_Item_1',\n            bnf: [['Minus', 'Item'], ['Item*']],\n            fragment: true\n        },\n        {\n            name: 'Minus',\n            bnf: [['\"-\"']]\n        },\n        {\n            name: 'Item',\n            bnf: [['RULE_WHITESPACE*', '%Primary', 'PrimaryDecoration?']],\n            fragment: true\n        },\n        {\n            name: 'PrimaryDecoration',\n            bnf: [['\"?\"'], ['\"*\"'], ['\"+\"']]\n        },\n        {\n            name: 'DecorationName',\n            bnf: [['\"ebnf://\"', /[^\\x5D#]+/]]\n        },\n        {\n            name: '%Primary',\n            bnf: [['NCName'], ['StringLiteral'], ['CharCode'], ['CharClass'], ['SubItem']],\n            fragment: true\n        },\n        {\n            name: 'SubItem',\n            bnf: [['\"(\"', 'RULE_WHITESPACE*', 'Choice', 'RULE_WHITESPACE*', '\")\"']]\n        },\n        {\n            name: 'StringLiteral',\n            bnf: [[`'\"'`, /[^\"]*/, `'\"'`], [`\"'\"`, /[^']*/, `\"'\"`]],\n            pinned: 1\n        },\n        {\n            name: 'CharCode',\n            bnf: [['\"#x\"', /[0-9a-zA-Z]+/]]\n        },\n        {\n            name: 'CharClass',\n            bnf: [[\"'['\", \"'^'?\", '%RULE_CharClass_1+', '\"]\"']]\n        },\n        {\n            name: '%RULE_CharClass_1',\n            bnf: [['CharCodeRange'], ['CharRange'], ['CharCode'], ['RULE_Char']],\n            fragment: true\n        },\n        {\n            name: 'RULE_Char',\n            bnf: [[/\\x09/], [/\\x0A/], [/\\x0D/], [/[\\x20-\\x5c]/], [/[\\x5e-\\uD7FF]/], [/[\\uE000-\\uFFFD]/]]\n        },\n        {\n            name: 'CharRange',\n            bnf: [['RULE_Char', '\"-\"', 'RULE_Char']]\n        },\n        {\n            name: 'CharCodeRange',\n            bnf: [['CharCode', '\"-\"', 'CharCode']]\n        },\n        {\n            name: 'RULE_WHITESPACE',\n            bnf: [['%RULE_WHITESPACE_CHAR*'], ['Comment', 'RULE_WHITESPACE*']]\n        },\n        {\n            name: 'RULE_S',\n            bnf: [['RULE_WHITESPACE', 'RULE_S*'], ['RULE_EOL', 'RULE_S*']]\n        },\n        {\n            name: '%RULE_WHITESPACE_CHAR',\n            bnf: [[/\\x09/], [/\\x20/]],\n            fragment: true\n        },\n        {\n            name: 'Comment',\n            bnf: [['\"/*\"', '%RULE_Comment_Body*', '\"*/\"']]\n        },\n        {\n            name: '%RULE_Comment_Body',\n            bnf: [['!\"*/\"', /[^*]/]],\n            fragment: true\n        },\n        {\n            name: 'RULE_EOL',\n            bnf: [[/\\x0D/, /\\x0A/], [/\\x0A/], [/\\x0D/]]\n        },\n        {\n            name: 'Link',\n            bnf: [[\"'['\", 'Url', \"']'\"]]\n        },\n        {\n            name: 'Url',\n            bnf: [[/[^\\x5D:/?#]/, '\"://\"', /[^\\x5D#]+/, '%Url1?']]\n        },\n        {\n            name: '%Url1',\n            bnf: [['\"#\"', 'NCName']],\n            fragment: true\n        }\n    ];\n    BNF.defaultParser = new Parser_1.Parser(BNF.RULES, { debug: false });\n    const preDecorationRE = /^(!|&)/;\n    const decorationRE = /(\\?|\\+|\\*)$/;\n    const subExpressionRE = /^%/;\n    function getBNFRule(name, parser) {\n        if (typeof name == 'string') {\n            if (preDecorationRE.test(name))\n                return '';\n            let subexpression = subExpressionRE.test(name);\n            if (subexpression) {\n                let decoration = decorationRE.exec(name);\n                let decorationText = decoration ? decoration[0] + ' ' : '';\n                let lonely = isLonelyRule(name, parser);\n                if (lonely)\n                    return getBNFBody(name, parser) + decorationText;\n                return '(' + getBNFBody(name, parser) + ')' + decorationText;\n            }\n            return name;\n        }\n        else {\n            return name.source\n                .replace(/\\\\(?:x|u)([a-zA-Z0-9]+)/g, '#x$1')\n                .replace(/\\[\\\\(?:x|u)([a-zA-Z0-9]+)-\\\\(?:x|u)([a-zA-Z0-9]+)\\]/g, '[#x$1-#x$2]');\n        }\n    }\n    /// Returns true if the rule is a string literal or regular expression without a descendant tree\n    function isLonelyRule(name, parser) {\n        let rule = Parser_1.findRuleByName(name, parser);\n        return (rule &&\n            rule.bnf.length == 1 &&\n            rule.bnf[0].length == 1 &&\n            (rule.bnf[0][0] instanceof RegExp || rule.bnf[0][0][0] == '\"' || rule.bnf[0][0][0] == \"'\"));\n    }\n    function getBNFChoice(rules, parser) {\n        return rules.map(x => getBNFRule(x, parser)).join(' ');\n    }\n    function getBNFBody(name, parser) {\n        let rule = Parser_1.findRuleByName(name, parser);\n        if (rule)\n            return rule.bnf.map(x => getBNFChoice(x, parser)).join(' | ');\n        return 'RULE_NOT_FOUND {' + name + '}';\n    }\n    function emit(parser) {\n        let acumulator = [];\n        parser.grammarRules.forEach(l => {\n            if (!/^%/.test(l.name)) {\n                let recover = l.recover ? ' /* { recoverUntil=' + l.recover + ' } */' : '';\n                acumulator.push(l.name + ' ::= ' + getBNFBody(l.name, parser) + recover);\n            }\n        });\n        return acumulator.join('\\n');\n    }\n    BNF.emit = emit;\n    let subitems = 0;\n    function restar(total, resta) {\n        console.log('reberia restar ' + resta + ' a ' + total);\n        throw new Error('Difference not supported yet');\n    }\n    function convertRegex(txt) {\n        return new RegExp(txt\n            .replace(/#x([a-zA-Z0-9]{4})/g, '\\\\u$1')\n            .replace(/#x([a-zA-Z0-9]{3})/g, '\\\\u0$1')\n            .replace(/#x([a-zA-Z0-9]{2})/g, '\\\\x$1')\n            .replace(/#x([a-zA-Z0-9]{1})/g, '\\\\x0$1'));\n    }\n    function getSubItems(tmpRules, seq, parentName) {\n        let anterior = null;\n        let bnfSeq = [];\n        seq.children.forEach((x, i) => {\n            if (x.type == 'Minus') {\n                restar(anterior, x);\n            }\n            else {\n            }\n            let decoration = seq.children[i + 1];\n            decoration = (decoration && decoration.type == 'PrimaryDecoration' && decoration.text) || '';\n            let preDecoration = '';\n            switch (x.type) {\n                case 'SubItem':\n                    let name = '%' + (parentName + subitems++);\n                    createRule(tmpRules, x, name);\n                    bnfSeq.push(preDecoration + name + decoration);\n                    break;\n                case 'NCName':\n                case 'StringLiteral':\n                    bnfSeq.push(preDecoration + x.text + decoration);\n                    break;\n                case 'CharCode':\n                case 'CharClass':\n                    if (decoration || preDecoration) {\n                        let newRule = {\n                            name: '%' + (parentName + subitems++),\n                            bnf: [[convertRegex(x.text)]]\n                        };\n                        tmpRules.push(newRule);\n                        bnfSeq.push(preDecoration + newRule.name + decoration);\n                    }\n                    else {\n                        bnfSeq.push(convertRegex(x.text));\n                    }\n                    break;\n                case 'PrimaryDecoration':\n                    break;\n                default:\n                    throw new Error(' HOW SHOULD I PARSE THIS? ' + x.type + ' -> ' + JSON.stringify(x.text));\n            }\n            anterior = x;\n        });\n        return bnfSeq;\n    }\n    function createRule(tmpRules, token, name) {\n        let bnf = token.children.filter(x => x.type == 'SequenceOrDifference').map(s => getSubItems(tmpRules, s, name));\n        let rule = {\n            name,\n            bnf\n        };\n        let recover = null;\n        bnf.forEach(x => {\n            recover = recover || x['recover'];\n            delete x['recover'];\n        });\n        if (name.indexOf('%') == 0)\n            rule.fragment = true;\n        if (recover)\n            rule.recover = recover;\n        tmpRules.push(rule);\n    }\n    function getRules(source, parser = BNF.defaultParser) {\n        let ast = parser.getAST(source);\n        if (!ast)\n            throw new Error('Could not parse ' + source);\n        if (ast.errors && ast.errors.length) {\n            throw ast.errors[0];\n        }\n        let tmpRules = [];\n        ast.children.filter(x => x.type == 'Production').map((x) => {\n            let name = x.children.filter(x => x.type == 'NCName')[0].text;\n            createRule(tmpRules, x, name);\n        });\n        return tmpRules;\n    }\n    BNF.getRules = getRules;\n    function Transform(source, subParser = BNF.defaultParser) {\n        return getRules(source.join(''), subParser);\n    }\n    BNF.Transform = Transform;\n    class Parser extends Parser_1.Parser {\n        constructor(source, options) {\n            const subParser = options && options.debugRulesParser === true ? new Parser_1.Parser(BNF.RULES, { debug: true }) : BNF.defaultParser;\n            super(getRules(source, subParser), options);\n        }\n        emitSource() {\n            return emit(this);\n        }\n    }\n    BNF.Parser = Parser;\n})(BNF || (BNF = {}));\nexports.default = BNF;\n//# sourceMappingURL=W3CEBNF.js.map", "(function(module) {\n    'use strict';\n\n    module.exports.is_uri = is_iri;\n    module.exports.is_http_uri = is_http_iri;\n    module.exports.is_https_uri = is_https_iri;\n    module.exports.is_web_uri = is_web_iri;\n    // Create aliases\n    module.exports.isUri = is_iri;\n    module.exports.isHttpUri = is_http_iri;\n    module.exports.isHttpsUri = is_https_iri;\n    module.exports.isWebUri = is_web_iri;\n\n\n    // private function\n    // internal URI spitter method - direct from RFC 3986\n    var splitUri = function(uri) {\n        var splitted = uri.match(/(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\n        return splitted;\n    };\n\n    function is_iri(value) {\n        if (!value) {\n            return;\n        }\n\n        // check for illegal characters\n        if (/[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i.test(value)) return;\n\n        // check for hex escapes that aren't complete\n        if (/%[^0-9a-f]/i.test(value)) return;\n        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        // scheme and path are required, though the path can be empty\n        if (!(scheme && scheme.length && path.length >= 0)) return;\n\n        // if authority is present, the path must be empty or begin with a /\n        if (authority && authority.length) {\n            if (!(path.length === 0 || /^\\//.test(path))) return;\n        } else {\n            // if authority is not present, the path must not start with //\n            if (/^\\/\\//.test(path)) return;\n        }\n\n        // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n        if (!/^[a-z][a-z0-9\\+\\-\\.]*$/.test(scheme.toLowerCase()))  return;\n\n        // re-assemble the URL per section 5.3 in RFC 3986\n        out += scheme + ':';\n        if (authority && authority.length) {\n            out += '//' + authority;\n        }\n\n        out += path;\n\n        if (query && query.length) {\n            out += '?' + query;\n        }\n\n        if (fragment && fragment.length) {\n            out += '#' + fragment;\n        }\n\n        return out;\n    }\n\n    function is_http_iri(value, allowHttps) {\n        if (!is_iri(value)) {\n            return;\n        }\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var port = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        if (!scheme)  return;\n\n        if(allowHttps) {\n            if (scheme.toLowerCase() != 'https') return;\n        } else {\n            if (scheme.toLowerCase() != 'http') return;\n        }\n\n        // fully-qualified URIs must have an authority section that is\n        // a valid host\n        if (!authority) {\n            return;\n        }\n\n        // enable port component\n        if (/:(\\d+)$/.test(authority)) {\n            port = authority.match(/:(\\d+)$/)[0];\n            authority = authority.replace(/:\\d+$/, '');\n        }\n\n        out += scheme + ':';\n        out += '//' + authority;\n        \n        if (port) {\n            out += port;\n        }\n        \n        out += path;\n        \n        if(query && query.length){\n            out += '?' + query;\n        }\n\n        if(fragment && fragment.length){\n            out += '#' + fragment;\n        }\n        \n        return out;\n    }\n\n    function is_https_iri(value) {\n        return is_http_iri(value, true);\n    }\n\n    function is_web_iri(value) {\n        return (is_http_iri(value) || is_https_iri(value));\n    }\n\n})(module);\n", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "/* eslint max-len: 0 */\r\nexport default {\r\n    // validation errors\r\n    AdditionalItemsError: \"Array at `{{pointer}}` may not have an additional item `{{key}}`\",\r\n    AdditionalPropertiesError: \"Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`\",\r\n    AllOfError: \"Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`\",\r\n    AnyOfError: \"Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`\",\r\n    ConstError: \"Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`\",\r\n    containsAnyError: \"The array at `{{pointer}}` must contain at least one item\",\r\n    ContainsArrayError: \"The property at `{{pointer}}` must not be an array\",\r\n    ContainsError: \"The array at `{{pointer}}` must contain an element that matches `{{schema}}`\",\r\n    EnumError: \"Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`\",\r\n    FormatDateError: \"Value `{{value}}` at `{{pointer}}` is not a valid date\",\r\n    FormatDateTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid date-time\",\r\n    FormatEmailError: \"Value `{{value}}` at `{{pointer}}` is not a valid email\",\r\n    FormatHostnameError: \"Value `{{value}}` at `{{pointer}}` is not a valid hostname\",\r\n    FormatIPV4Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address\",\r\n    FormatIPV4LeadingZeroError: \"IPv4 addresses starting with zero are invalid, since they are interpreted as octals\",\r\n    FormatIPV6Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address\",\r\n    FormatIPV6LeadingZeroError: \"IPv6 addresses starting with zero are invalid, since they are interpreted as octals\",\r\n    FormatJSONPointerError: \"Value `{{value}}` at `{{pointer}}` is not a valid json-pointer\",\r\n    FormatRegExError: \"Value `{{value}}` at `{{pointer}}` is not a valid regular expression\",\r\n    FormatTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid time\",\r\n    FormatURIError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri\",\r\n    FormatURIReferenceError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-reference\",\r\n    FormatURITemplateError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-template\",\r\n    FormatURLError: \"Value `{{value}}` at `{{pointer}}` is not a valid url\",\r\n    InvalidDataError: \"No value may be specified in `{{pointer}}`\",\r\n    InvalidPropertyNameError: \"Invalid property name `{{property}}` at `{{pointer}}`\",\r\n    MaximumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum\",\r\n    MaxItemsError: \"Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\r\n    MaxLengthError: \"Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.\",\r\n    MaxPropertiesError: \"Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\r\n    MinimumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum\",\r\n    MinItemsError: \"Too few items in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`\",\r\n    MinItemsOneError: \"At least one item is required in `{{pointer}}`\",\r\n    MinLengthError: \"Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.\",\r\n    MinLengthOneError: \"A value is required in `{{pointer}}`\",\r\n    MinPropertiesError: \"Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`\",\r\n    MissingDependencyError: \"The required propery '{{missingProperty}}' in `{{pointer}}` is missing\",\r\n    MissingOneOfPropertyError: \"Value at `{{pointer}}` property: `{{property}}`\",\r\n    MultipleOfError: \"Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`\",\r\n    MultipleOneOfError: \"Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`\",\r\n    NoAdditionalPropertiesError: \"Additional property `{{property}}` in `{{pointer}}` is not allowed\",\r\n    NotError: \"Value `{{value}}` at pointer should not match schema `{{not}}`\",\r\n    OneOfError: \"Value `{{value}}` in `{{pointer}}` does not match any given oneof schema\",\r\n    OneOfPropertyError: \"Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`\",\r\n    PatternError: \"Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`\",\r\n    PatternPropertiesError: \"Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}\",\r\n    RequiredPropertyError: \"The required property `{{key}}` is missing at `{{pointer}}`\",\r\n    TypeError: \"Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`\",\r\n    UndefinedValueError: \"Value must not be undefined in `{{pointer}}`\",\r\n    UniqueItemsError: \"Expected unique items in {{pointer}}: duplicate value `{{value}}` found at {{itemPointer}} and {{duplicatePointer}}\",\r\n    UnknownPropertyError: \"Could not find a valid schema for property `{{pointer}}` within object\",\r\n    ValueNotEmptyError: \"A value for `{{property}}` is required at `{{pointer}}`\"\r\n};\r\n", "/**\r\n * Renders data into a string by {{variables}}.\r\n * Given a template string, removes all {{property}} substrings and replaces them with the property in the given data\r\n *\r\n * @param template - template string containing variables in handelbars/mustache style\r\n * @param data - flat object containing properties matching variables\r\n * @return rendered string\r\n */\r\nexport default function render(template, data = {}) {\r\n    return template.replace(/\\{\\{\\w+\\}\\}/g, match => data[match.replace(/[{}]/g, \"\")]);\r\n}\r\n", "import strings from \"../config/strings\";\r\nimport render from \"./render\";\r\n/**\r\n * Renders the given string as defined in __@see config/strings.js__\r\n * @param keyword\r\n * @param data - template data\r\n * @param fallback - fallback template\r\n * @return resulting string\r\n */\r\nexport default function __(keyword, data, fallback = keyword) {\r\n    const template = strings[keyword] || fallback;\r\n    return render(template, data);\r\n}\r\n", "import __ from \"./__\";\r\nfunction dashCase(text) {\r\n    return text.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\r\n}\r\nexport function createError(name, data) {\r\n    return {\r\n        type: \"error\",\r\n        name,\r\n        code: dashCase(name),\r\n        message: __(name, data),\r\n        data\r\n    };\r\n}\r\n/**\r\n * Creates a custom Error-Constructor which instances may be identified by `customError instanceof Error`. Its messages\r\n * are defined by strings-object @see config/strings.ts\r\n *\r\n * @param name - id of error (camelcased)\r\n * @return error constructor function\r\n */\r\nexport function createCustomError(name) {\r\n    return createError.bind(null, name);\r\n}\r\n", "const toString = Object.prototype.toString;\r\nexport default function getTypeOf(value) {\r\n    const type = toString\r\n        .call(value)\r\n        .match(/\\s([^\\]]+)\\]/)\r\n        .pop()\r\n        .toLowerCase();\r\n    if (type === \"file\") {\r\n        return \"object\";\r\n    }\r\n    return type;\r\n}\r\n", "/**\r\n * ts type guard for json error\r\n * @returns true if passed type is a JSONError\r\n */\r\nexport function isJSONError(error) {\r\n    return (error === null || error === void 0 ? void 0 : error.type) === \"error\";\r\n}\r\n", "import { isJSONError } from \"../types\";\r\nexport function isPromise(obj) {\r\n    return obj instanceof Promise;\r\n}\r\nexport function errorOrPromise(error) {\r\n    return isJSONError(error) || isPromise(error);\r\n}\r\nexport function errorsOnly(error) {\r\n    return isJSONError(error);\r\n}\r\n", "export default function flattenArray(list, result = []) {\r\n    for (let i = 0; i < list.length; i += 1) {\r\n        const item = list[i];\r\n        if (Array.isArray(item)) {\r\n            flattenArray(item, result);\r\n        }\r\n        else {\r\n            result.push(item);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n", "export default {\r\n    DECLARATOR_ONEOF: \"oneOfProperty\",\r\n    GET_TEMPLATE_RECURSION_LIMIT: 1,\r\n    floatingPointPrecision: 10000,\r\n    propertyBlacklist: [\"_id\"]\r\n};\r\n", "import { errorOrPromise } from \"./utils/filter\";\r\nimport flattenArray from \"./utils/flattenArray\";\r\nimport settings from \"./config/settings\";\r\nimport { isJSONError } from \"./types\";\r\nconst { DECLARATOR_ONEOF } = settings;\r\n/**\r\n * Selects and returns a oneOf schema for the given data\r\n *\r\n * @param core - validator\r\n * @param data\r\n * @param schema - current json schema containing property oneOf\r\n * @param pointer - json pointer to data\r\n * @return oneOf schema or an error\r\n */\r\nexport default function resolveOneOf(core, data, schema = core.rootSchema, pointer = \"#\") {\r\n    // !keyword: oneOfProperty\r\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\r\n    // oneOf value (if set in data)\r\n    // @fixme\r\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\r\n    // this case (data != null) should not be necessary\r\n    if (data != null && schema[DECLARATOR_ONEOF]) {\r\n        const errors = [];\r\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\r\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\r\n        if (oneOfValue === undefined) {\r\n            return core.errors.missingOneOfPropertyError({ property: oneOfProperty, pointer });\r\n        }\r\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\r\n            const one = core.resolveRef(schema.oneOf[i]);\r\n            const oneOfPropertySchema = core.step(oneOfProperty, one, data, pointer);\r\n            if (isJSONError(oneOfPropertySchema)) {\r\n                return oneOfPropertySchema;\r\n            }\r\n            let result = flattenArray(core.validate(oneOfValue, oneOfPropertySchema, pointer));\r\n            result = result.filter(errorOrPromise);\r\n            if (result.length > 0) {\r\n                errors.push(...result);\r\n            }\r\n            else {\r\n                return one; // return resolved schema\r\n            }\r\n        }\r\n        return core.errors.oneOfPropertyError({\r\n            property: oneOfProperty,\r\n            value: oneOfValue,\r\n            pointer,\r\n            errors\r\n        });\r\n    }\r\n    const matches = [];\r\n    const errors = [];\r\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\r\n        const one = core.resolveRef(schema.oneOf[i]);\r\n        let result = flattenArray(core.validate(data, one, pointer));\r\n        result = result.filter(errorOrPromise);\r\n        if (result.length > 0) {\r\n            errors.push(...result);\r\n        }\r\n        else {\r\n            matches.push(one);\r\n        }\r\n    }\r\n    if (matches.length === 1) {\r\n        return matches[0];\r\n    }\r\n    if (matches.length > 1) {\r\n        return core.errors.multipleOneOfError({\r\n            value: data,\r\n            pointer,\r\n            matches\r\n        });\r\n    }\r\n    return core.errors.oneOfError({\r\n        value: JSON.stringify(data),\r\n        pointer,\r\n        oneOf: schema.oneOf,\r\n        errors\r\n    });\r\n}\r\n", "export default (value) => JSON.parse(JSON.stringify(value));\r\n", "import deepmerge from \"deepmerge\";\r\nconst overwriteMerge = (destinationArray, sourceArray) => sourceArray;\r\n/**\r\n * returns a new json-schema, where properties are combined and arrays are replaced\r\n */\r\nexport default (a, b) => deepmerge(a, b, { arrayMerge: overwriteMerge });\r\n// var d = c.filter((item, pos) => c.indexOf(item) === pos)\r\nconst mergeUniqueItems = (destinationArray, sourceArray) => {\r\n    const all = destinationArray.concat(sourceArray);\r\n    return all.filter((item, pos) => all.indexOf(item) === pos);\r\n};\r\n/**\r\n * returns a new json-schema, where properties are combined and arrays are replaced\r\n */\r\nexport const mergeArraysUnique = (a, b) => deepmerge(a, b, { arrayMerge: mergeUniqueItems });\r\n", "/**\r\n * resolveAllOf is tricky:\r\n *\r\n * resolve all merges all schemas altough each schema in the list must be used\r\n * for validation. But to use this as a template schema to create data and a\r\n * resolved schema, structural data must be merged. Currently, it is merged in\r\n * all case, but separately validated and resolved. This will break at some\r\n * point, requiring us to be more specific on our current intent (validation\r\n * vs get (resolved) schema)\r\n */\r\nimport copy from \"./utils/copy\";\r\nimport { mergeArraysUnique } from \"./utils/merge\";\r\n/**\r\n * resolves schema\r\n * when complete this will have much duplication to step.object etc\r\n */\r\nfunction resolveSchema(draft, schemaToResolve, data) {\r\n    var _a;\r\n    const schema = { ...((_a = draft.resolveRef(schemaToResolve)) !== null && _a !== void 0 ? _a : {}) };\r\n    // @draft >= 07\r\n    if (schema.if && (schema.then || schema.else)) {\r\n        const isValid = draft.isValid(data, schema.if);\r\n        if (isValid && schema.then) {\r\n            return resolveSchema(draft, schema.then, data);\r\n        }\r\n        if (!isValid && schema.else) {\r\n            return resolveSchema(draft, schema.else, data);\r\n        }\r\n        delete schema.if;\r\n        delete schema.then;\r\n        delete schema.else;\r\n    }\r\n    return schema;\r\n}\r\nexport default function resolveAllOf(draft, data, schema = draft.rootSchema, pointer = \"#\") {\r\n    let mergedSchema = copy(schema);\r\n    for (let i = 0; i < schema.allOf.length; i += 1) {\r\n        const allOfSchema = resolveSchema(draft, schema.allOf[i], data);\r\n        mergedSchema = mergeArraysUnique(mergedSchema, allOfSchema);\r\n        data = draft.getTemplate(data, mergedSchema);\r\n    }\r\n    delete mergedSchema.allOf;\r\n    return mergedSchema;\r\n}\r\n", "import { errorOrPromise } from \"./utils/filter\";\r\nimport flattenArray from \"./utils/flattenArray\";\r\nimport getTypeOf from \"./getTypeOf\";\r\nimport settings from \"./config/settings\";\r\nimport { isJSONError } from \"./types\";\r\nconst { DECLARATOR_ONEOF } = settings;\r\n/**\r\n * Returns a ranking for the data and given schema\r\n *\r\n * @param core\r\n * @param - json schema type: object\r\n * @param data\r\n * @param [pointer]\r\n * @return ranking value (higher is better)\r\n */\r\nfunction fuzzyObjectValue(core, one, data, pointer) {\r\n    if (data == null || one.properties == null) {\r\n        return -1;\r\n    }\r\n    let value = 0;\r\n    const keys = Object.keys(one.properties);\r\n    for (let i = 0; i < keys.length; i += 1) {\r\n        const key = keys[i];\r\n        if (data[key] != null && core.isValid(data[key], one.properties[key], pointer)) {\r\n            value += 1;\r\n        }\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Selects and returns a oneOf schema for the given data\r\n *\r\n * @param core\r\n * @param data\r\n * @param [schema] - current json schema containing property oneOf\r\n * @param [pointer] - json pointer to data\r\n * @return oneOf schema or an error\r\n */\r\nexport default function resolveOneOf(core, data, schema = core.rootSchema, pointer = \"#\") {\r\n    // !keyword: oneOfProperty\r\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\r\n    // oneOf value (if set in data)\r\n    // @fixme\r\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\r\n    // this case (data != null) should not be necessary\r\n    if (data != null && schema[DECLARATOR_ONEOF]) {\r\n        const errors = [];\r\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\r\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\r\n        if (oneOfValue === undefined) {\r\n            return core.errors.missingOneOfPropertyError({ property: oneOfProperty, pointer });\r\n        }\r\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\r\n            const one = core.resolveRef(schema.oneOf[i]);\r\n            const oneOfPropertySchema = core.step(oneOfProperty, one, data, pointer);\r\n            if (isJSONError(oneOfPropertySchema)) {\r\n                return oneOfPropertySchema;\r\n            }\r\n            let result = flattenArray(core.validate(oneOfValue, oneOfPropertySchema, pointer));\r\n            result = result.filter(errorOrPromise);\r\n            if (result.length > 0) {\r\n                errors.push(...result);\r\n            }\r\n            else {\r\n                return one; // return resolved schema\r\n            }\r\n        }\r\n        return core.errors.oneOfPropertyError({\r\n            property: oneOfProperty,\r\n            value: oneOfValue,\r\n            pointer,\r\n            errors\r\n        });\r\n    }\r\n    // keyword: oneOf\r\n    const matches = [];\r\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\r\n        const one = core.resolveRef(schema.oneOf[i]);\r\n        if (core.isValid(data, one, pointer)) {\r\n            matches.push(one);\r\n        }\r\n    }\r\n    if (matches.length === 1) {\r\n        return matches[0];\r\n    }\r\n    // fuzzy match oneOf\r\n    if (getTypeOf(data) === \"object\") {\r\n        let schemaOfItem;\r\n        let fuzzyGreatest = 0;\r\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\r\n            const one = core.resolveRef(schema.oneOf[i]);\r\n            const fuzzyValue = fuzzyObjectValue(core, one, data);\r\n            if (fuzzyGreatest < fuzzyValue) {\r\n                fuzzyGreatest = fuzzyValue;\r\n                schemaOfItem = schema.oneOf[i];\r\n            }\r\n        }\r\n        if (schemaOfItem === undefined) {\r\n            return core.errors.oneOfError({\r\n                value: JSON.stringify(data),\r\n                pointer,\r\n                oneOf: schema.oneOf\r\n            });\r\n        }\r\n        return schemaOfItem;\r\n    }\r\n    if (matches.length > 1) {\r\n        return core.errors.multipleOneOfError({ matches, data, pointer });\r\n    }\r\n    return core.errors.oneOfError({ value: JSON.stringify(data), pointer, oneOf: schema.oneOf });\r\n}\r\n", "export default function resolveRef(schema, rootSchema) {\r\n    if (schema == null || schema.$ref == null) {\r\n        return schema;\r\n    }\r\n    if (schema.getRoot) {\r\n        // we actually always need to resolve the schema like this, since returned subschemas\r\n        // must resolve relative from their schema\r\n        const resolvedSchema = schema.getRoot().getRef(schema);\r\n        // console.log(schema.$ref, \"=>\", resolvedSchema);\r\n        return resolvedSchema;\r\n    }\r\n    // tryout - this should never be called, except we missed something\r\n    const resolvedSchema = rootSchema.getRef(schema);\r\n    return resolvedSchema;\r\n}\r\n", "export default function resolveRefMerge(schema, rootSchema) {\r\n    if (schema == null || schema.$ref == null) {\r\n        return schema;\r\n    }\r\n    const resolvedSchema = rootSchema.getRef(schema);\r\n    const mergedSchema = Object.assign({}, resolvedSchema, schema);\r\n    delete mergedSchema.$ref;\r\n    // @todo the following might not be safe nor incomplete\r\n    Object.defineProperty(mergedSchema, \"__ref\", { enumerable: false, value: schema.__ref });\r\n    Object.defineProperty(mergedSchema, \"getRoot\", { enumerable: false, value: schema.getRoot });\r\n    return mergedSchema;\r\n}\r\n", "import gp from \"@sagold/json-pointer\";\r\nimport { isJSONError } from \"./types\";\r\nconst emptyObject = {};\r\n/**\r\n * Returns the json-schema of a data-json-pointer.\r\n *\r\n *  Notes\r\n *      - Uses draft.step to walk through data and schema\r\n *\r\n * @param draft\r\n * @param pointer - json pointer in data to get the json schema for\r\n * @param [data] - the data object, which includes the json pointers value. This is optional, as\r\n *    long as no oneOf, anyOf, etc statement is part of the pointers schema\r\n * @param [schema] - the json schema to iterate. Defaults to draft.rootSchema\r\n * @return json schema object of the json-pointer or an error\r\n */\r\nexport default function getSchema(draft, pointer, data, schema = draft.rootSchema) {\r\n    const frags = gp.split(pointer);\r\n    schema = draft.resolveRef(schema);\r\n    return _get(draft, schema, frags, pointer, data);\r\n}\r\nfunction _get(draft, schema, frags, pointer, data = emptyObject) {\r\n    if (frags.length === 0) {\r\n        return draft.resolveRef(schema);\r\n    }\r\n    const key = frags.shift(); // step key\r\n    schema = draft.step(key, schema, data, pointer); // step schema\r\n    if (isJSONError(schema)) {\r\n        return schema;\r\n    }\r\n    // @ts-ignore\r\n    data = data[key]; // step data\r\n    return _get(draft, schema, frags, `${pointer}/${key}`, data);\r\n}\r\n", "export class Draft {\r\n    constructor(config, schema) {\r\n        /** cache for remote schemas */\r\n        this.remotes = {};\r\n        /** error creators by id */\r\n        this.errors = {};\r\n        /** map for valid keywords of a type  */\r\n        this.typeKeywords = {};\r\n        /** keyword validators  */\r\n        this.validateKeyword = {};\r\n        /** type validators  */\r\n        this.validateType = {};\r\n        /** format validators  */\r\n        this.validateFormat = {};\r\n        this.config = config;\r\n        this.typeKeywords = JSON.parse(JSON.stringify(config.typeKeywords));\r\n        this.validateKeyword = Object.assign({}, config.validateKeyword);\r\n        this.validateType = Object.assign({}, config.validateType);\r\n        this.validateFormat = Object.assign({}, config.validateFormat);\r\n        this.errors = Object.assign({}, config.errors);\r\n        this.setSchema(schema);\r\n    }\r\n    get rootSchema() {\r\n        return this.__rootSchema;\r\n    }\r\n    set rootSchema(rootSchema) {\r\n        if (rootSchema == null) {\r\n            return;\r\n        }\r\n        this.__rootSchema = this.config.compileSchema(this, rootSchema);\r\n    }\r\n    /**\r\n     * register a json-schema to be referenced from another json-schema\r\n     * @param url - base-url of json-schema (aka id)\r\n     * @param schema - json-schema root\r\n     */\r\n    addRemoteSchema(url, schema) {\r\n        this.config.addRemoteSchema(this, url, schema);\r\n    }\r\n    compileSchema(schema) {\r\n        var _a;\r\n        return this.config.compileSchema(this, schema, (_a = this.rootSchema) !== null && _a !== void 0 ? _a : schema);\r\n    }\r\n    createSchemaOf(data) {\r\n        return this.config.createSchemaOf(data);\r\n    }\r\n    /**\r\n     * Iterates over data, retrieving its schema\r\n     *\r\n     * @param data - the data to iterate\r\n     * @param callback - will be called with (schema, data, pointer) on each item\r\n     * @param [schema] - the schema matching the data. Defaults to rootSchema\r\n     * @param [pointer] - pointer to current data. Default to rootPointer\r\n     */\r\n    each(data, callback, schema, pointer) {\r\n        return this.config.each(this, data, callback, schema, pointer);\r\n    }\r\n    eachSchema(callback, schema = this.rootSchema) {\r\n        return this.config.eachSchema(schema, callback);\r\n    }\r\n    getChildSchemaSelection(property, schema) {\r\n        return this.config.getChildSchemaSelection(this, property, schema);\r\n    }\r\n    /**\r\n     * Returns the json-schema of a data-json-pointer.\r\n     * Notes\r\n     *   - Uses core.step to walk through data and schema\r\n     *\r\n     * @param pointer - json pointer in data to get the json schema for\r\n     * @param [data] - the data object, which includes the json pointers value. This is optional, as\r\n     *    long as no oneOf, anyOf, etc statement is part of the pointers schema\r\n     * @param [schema] - the json schema to iterate. Defaults to core.rootSchema\r\n     * @return json schema object of the json-pointer or an error\r\n     */\r\n    getSchema(pointer = \"#\", data, schema) {\r\n        return this.config.getSchema(this, pointer, data, schema);\r\n    }\r\n    /**\r\n     * Create data object matching the given schema\r\n     *\r\n     * @param [data] - optional template data\r\n     * @param [schema] - json schema, defaults to rootSchema\r\n     * @return created template data\r\n     */\r\n    getTemplate(data, schema, opts) {\r\n        return this.config.getTemplate(this, data, schema, opts);\r\n    }\r\n    isValid(data, schema, pointer) {\r\n        return this.config.isValid(this, data, schema, pointer);\r\n    }\r\n    resolveAnyOf(data, schema, pointer) {\r\n        return this.config.resolveAnyOf(this, data, schema, pointer);\r\n    }\r\n    resolveAllOf(data, schema, pointer) {\r\n        return this.config.resolveAllOf(this, data, schema, pointer);\r\n    }\r\n    resolveRef(schema) {\r\n        return this.config.resolveRef(schema, this.rootSchema);\r\n    }\r\n    resolveOneOf(data, schema, pointer) {\r\n        return this.config.resolveOneOf(this, data, schema, pointer);\r\n    }\r\n    setSchema(schema) {\r\n        this.rootSchema = schema;\r\n    }\r\n    /**\r\n     * Returns the json-schema of the given object property or array item.\r\n     * e.g. it steps by one key into the data\r\n     *\r\n     *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\r\n     *  returns the correct schema.\r\n     *\r\n     * @param  key       - property-name or array-index\r\n     * @param  schema    - json schema of current data\r\n     * @param  data      - parent of key\r\n     * @param  [pointer] - pointer to schema and data (parent of key)\r\n     * @return Schema or Error if failed resolving key\r\n     */\r\n    step(key, schema, data, pointer) {\r\n        return this.config.step(this, key, schema, data, pointer);\r\n    }\r\n    /**\r\n     * Validate data by a json schema\r\n     *\r\n     * @param value - value to validate\r\n     * @param [schema] - json schema, defaults to rootSchema\r\n     * @param [pointer] - json pointer pointing to value (used for error-messages only)\r\n     * @return list of errors or empty\r\n     */\r\n    validate(data, schema, pointer) {\r\n        return this.config.validate(this, data, schema, pointer);\r\n    }\r\n}\r\n", "/**\r\n * register a json-schema to be referenced from another json-schema\r\n * @param url    base-url of json-schema (aka id)\r\n * @param schema\r\n */\r\nexport default function addRemoteSchema(draft, url, schema) {\r\n    schema.id = schema.id || url;\r\n    draft.remotes[url] = draft.compileSchema(schema);\r\n}\r\n", "import gp from \"@sagold/json-pointer\";\r\nimport getTypeDefs from \"./schema/getTypeDefs\";\r\nconst isObject = (value) => Object.prototype.toString.call(value) === \"[object Object]\";\r\nfunction nextTypeDefs(schema, pointer) {\r\n    if (this.callback(schema, pointer) === true) {\r\n        // eslint-disable-line no-invalid-this\r\n        return; // stop iteration\r\n    }\r\n    const defs = getTypeDefs(schema);\r\n    // eslint-disable-next-line no-invalid-this\r\n    defs.forEach((next) => this.nextTypeDefs(next.def, gp.join(pointer, next.pointer, false)));\r\n}\r\nfunction eachDefinition(walk, schema, pointer, key = \"definitions\") {\r\n    const defs = schema[key];\r\n    Object.keys(defs).forEach((defId) => {\r\n        if (defs[defId] === false || isObject(defs[defId])) {\r\n            walk.nextTypeDefs(defs[defId], gp.join(pointer, key, defId, false));\r\n            return;\r\n        }\r\n        // console.log(`Invalid schema in ${pointer}/${key}/${defId}`);\r\n    });\r\n}\r\nexport function eachSchema(schema, callback, pointer = \"#\") {\r\n    const walk = { callback, nextTypeDefs };\r\n    walk.nextTypeDefs(schema, pointer);\r\n    if (schema.definitions != null) {\r\n        walk.callback = (defschema, schemaPointer) => {\r\n            callback(defschema, schemaPointer);\r\n            if (defschema.definitions != null) {\r\n                eachDefinition(walk, defschema, schemaPointer);\r\n            }\r\n        };\r\n        eachDefinition(walk, schema, pointer);\r\n    }\r\n    if (schema.$defs != null) {\r\n        walk.callback = (defschema, schemaPointer) => {\r\n            callback(defschema, schemaPointer);\r\n            if (defschema.definitions != null) {\r\n                eachDefinition(walk, defschema, schemaPointer);\r\n            }\r\n        };\r\n        eachDefinition(walk, schema, pointer, \"$defs\");\r\n    }\r\n}\r\n", "import gp from \"@sagold/json-pointer\";\r\nimport { get } from \"@sagold/json-query\";\r\nimport getTypeId from \"./getTypeId\";\r\nimport types from \"./types\";\r\nconst isObject = (value) => Object.prototype.toString.call(value) === \"[object Object]\";\r\n/**\r\n * Returns a list of all (direct) type definitions from the given schema\r\n * @param schema\r\n * @return list of type definition, given as { pointer, def }\r\n */\r\nexport default function getTypeDefs(schema) {\r\n    const defs = [];\r\n    const id = getTypeId(schema);\r\n    if (id == null) {\r\n        return defs;\r\n    }\r\n    let type;\r\n    if (Array.isArray(id)) {\r\n        // since types can also be declared as a set of types, merge the definitions\r\n        // maybe this will require a more sophisticated approach\r\n        type = {};\r\n        for (let i = 0, l = id.length; i < l; i += 1) {\r\n            Object.assign(type, types[id[i]]);\r\n        }\r\n    }\r\n    else {\r\n        type = types[id];\r\n    }\r\n    if (type.definitions == null) {\r\n        return defs;\r\n    }\r\n    type.definitions.forEach((query) => {\r\n        get(schema, query, (value, key, parent, pointer) => {\r\n            if (isObject(value) && getTypeId(value)) {\r\n                defs.push({ pointer: gp.join(gp.split(pointer), false), def: value });\r\n            }\r\n        });\r\n    });\r\n    return defs;\r\n}\r\n", "import EBNF from \"ebnf/dist/Grammars/W3CEBNF\";\nimport { jsonQueryGrammar } from \"./jsonQueryGrammar\";\nconst valid = /(children|text|type|start|end|rest|errors|fullText|\\d+)/;\nconst subset = /(children|text|type|\\d+)/;\nconst toJSON = (ast) => JSON.stringify(ast, (key, value) => (key === \"\" || valid.test(key) ? value : undefined), 2);\nconst toSmallJSON = (ast) => JSON.stringify(ast, (key, value) => key === \"\" || (key === \"rest\" && value !== \"\") || subset.test(key)\n    ? value\n    : undefined, 2);\nconst parser = new EBNF.Parser(jsonQueryGrammar);\nexport const parse = (query) => parser.getAST(query);\nexport const reduce = (ast) => JSON.parse(toSmallJSON(ast));\nexport { toJSON };\n", "export const propertyRegex = \"[^?/{}*,()#]+\";\n// W3C ENBF grammar\n// https://github.com/lys-lang/node-ebnf/blob/master/test/W3CEBNF.spec.ts\n// https://www.w3.org/TR/xml/#sec-notation\nexport const jsonQueryGrammar = `\nroot ::= (\"#\" recursion | recursion | (query | pattern) recursion* | \"#\" SEP? | SEP)\nrecursion ::= (SEP query | pattern)*\n\nquery ::= (ESC escaped ESC | property | all | any | regex) typecheck? lookahead?\nproperty ::= ${propertyRegex}\nregex ::= \"{\" [^}]+ \"}\"\nSEP ::= \"/\"\nall ::= \"**\"\nany ::= \"*\"\n\ntypecheck ::= \"?:\" (\"value\" | \"boolean\" | \"string\" | \"number\" | \"object\" | \"array\")\nlookahead ::= \"?\" expression ((andExpr | orExpr) expression)*\nandExpr ::= S? \"&&\" S?\norExpr ::= S? \"||\" S?\n\nexpression ::= (exprProperty | ESC escaped ESC) ((isnot | is) (exprProperty | regex | ESC escaped ESC))*\nexprProperty ::= [a-zA-Z0-9-_ $]+\nescaped ::= [^\"]+\nis ::= \":\"\nisnot ::= \":!\"\nESC ::= '\"'\n\npattern ::= S? \"(\" (SEP query | pattern (orPattern? pattern)*)* \")\" quantifier? S? lookahead?\nquantifier ::= \"+\" | \"*\" | [0-9]+\norPattern ::= S? \",\" S?\n\nS ::= [ ]*\n`;\n", "const join = (a, b) => `${a}/${b}`;\nimport { VALUE_INDEX, POINTER_INDEX } from \"./keys\";\nconst toString = Object.prototype.toString;\nconst rContainer = /Object|Array/;\nconst isContainer = (v) => rContainer.test(toString.call(v));\nconst getTypeOf = (v) => toString\n    .call(v)\n    .match(/\\s([^\\]]+)\\]/)\n    .pop()\n    .toLowerCase();\nfunction nodeAsRegex(node) {\n    return new RegExp(node.text.replace(/(^{|}$)/g, \"\"));\n}\n/**\n * Iterates over object or array, passing each key, value and parentObject to the callback\n * @param value - to iterate\n * @param callback - receiving key on given input value\n */\nfunction forEach(parent, callback) {\n    if (Array.isArray(parent)) {\n        parent.forEach(callback);\n    }\n    else if (Object.prototype.toString.call(parent) === \"[object Object]\") {\n        Object.keys(parent).forEach(function (key) {\n            callback(parent[key], key, parent);\n        });\n    }\n}\n/**\n * Returns all keys of the given input data\n * @param  value\n * @return {Array} containing keys of given value\n */\nfunction getKeys(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (value, index) {\n            return `${index}`;\n        });\n    }\n    if (Object.prototype.toString.call(value) === \"[object Object]\") {\n        return Object.keys(value);\n    }\n    return [];\n}\nconst cache = {\n    mem: [],\n    get(entry, prop) {\n        const v = entry[VALUE_INDEX][prop];\n        if (cache.mem.includes(v)) {\n            return undefined;\n        }\n        if (isContainer(v)) {\n            cache.mem.push(v);\n        }\n        return [v, prop, entry[VALUE_INDEX], join(entry[POINTER_INDEX], prop)];\n    },\n    reset() {\n        cache.mem.length = 0;\n    },\n};\nconst expand = {\n    any(node, entry) {\n        const value = entry[VALUE_INDEX];\n        return (getKeys(value)\n            // .map(prop => cache.get(entry, prop));\n            .map((prop) => [\n            value[prop],\n            prop,\n            value,\n            join(entry[POINTER_INDEX], prop),\n        ]));\n    },\n    all(node, entry) {\n        const result = [entry];\n        forEach(entry[VALUE_INDEX], (value, prop) => {\n            const childEntry = cache.get(entry, prop);\n            // const childEntry = [value, prop, entry[VALUE_INDEX], join(entry[POINTER_INDEX], prop)];\n            childEntry && result.push(...expand.all(node, childEntry));\n        });\n        return result;\n    },\n    regex(node, entry) {\n        const regex = nodeAsRegex(node);\n        const value = entry[VALUE_INDEX];\n        return getKeys(value)\n            .filter((prop) => regex.test(prop))\n            .map((prop) => [\n            value[prop],\n            prop,\n            value,\n            join(entry[POINTER_INDEX], prop),\n        ]);\n    },\n};\nconst select = {\n    // alias to property (but escaped)\n    escaped: (node, entry) => select.property(node, entry),\n    property: (node, entry) => {\n        const prop = node.text;\n        if (entry[VALUE_INDEX] && entry[VALUE_INDEX][prop] !== undefined) {\n            return [\n                entry[VALUE_INDEX][prop],\n                prop,\n                entry[VALUE_INDEX],\n                join(entry[POINTER_INDEX], prop),\n            ];\n        }\n    },\n    typecheck: (node, entry) => {\n        const checkedTyped = node.text.replace(/^\\?:/, \"\");\n        if (checkedTyped === \"value\") {\n            return isContainer(entry[VALUE_INDEX]) ? undefined : entry;\n        }\n        const type = getTypeOf(entry[VALUE_INDEX]);\n        if (type === checkedTyped) {\n            return entry;\n        }\n    },\n    lookahead: (node, entry) => {\n        let valid = true;\n        let or = false;\n        node.children.forEach((expr) => {\n            if (expr.type === \"expression\") {\n                const isValid = select.expression(expr, entry) !== undefined;\n                valid = or === true ? valid || isValid : valid && isValid;\n            }\n            else {\n                or = expr.type === \"orExpr\";\n            }\n        });\n        return valid ? entry : undefined;\n    },\n    expression: (node, entry) => {\n        const prop = node.children[0].text;\n        const cmp = node.children[1];\n        const test = node.children[2];\n        const value = entry[VALUE_INDEX];\n        if (isContainer(value) === false) {\n            return undefined;\n        }\n        return expressionMatches(value[prop], cmp, test) ? entry : undefined;\n    },\n};\nfunction expressionMatches(value, cmp, test) {\n    if (cmp === undefined) {\n        return value !== undefined;\n    }\n    let valid;\n    const valueString = `${value}`;\n    if (test.type === \"regex\") {\n        const regex = nodeAsRegex(test);\n        valid = regex.test(valueString);\n    }\n    else {\n        valid = valueString === test.text;\n    }\n    if (cmp.type === \"isnot\") {\n        valid = valid === false && value !== undefined;\n    }\n    return valid;\n}\nexport { expand, select, cache };\n", "import { expand, select, cache } from \"./nodes\";\nimport { VALUE_INDEX, KEY_INDEX, PARENT_INDEX, POINTER_INDEX } from \"./keys\";\nfunction collect(func, input, node, pointer) {\n    const result = [];\n    for (let i = 0, l = input.length; i < l; i += 1) {\n        result.push(...func(node, input[i], node, pointer));\n    }\n    return result;\n}\nfunction reduce(func, input, node, pointer) {\n    const result = [];\n    for (let i = 0, l = input.length; i < l; i += 1) {\n        const output = func(node, input[i], pointer);\n        if (output) {\n            result.push(output);\n        }\n    }\n    return result;\n}\nfunction query(data, ast, pointer) {\n    let result = data;\n    ast.children.forEach((node) => {\n        if (expand[node.type]) {\n            result = collect(expand[node.type], result, node, pointer);\n        }\n        else if (select[node.type]) {\n            result = reduce(select[node.type], result, node, pointer);\n        }\n        else {\n            throw new Error(`Unknown filter ${node.type}`);\n        }\n    });\n    return result;\n}\nfunction runPatternOnce(inputSet, ast, pointer) {\n    const resultingSet = [];\n    let workingSet = inputSet;\n    ast.children.forEach((node) => {\n        if (node.type === \"orPattern\") {\n            resultingSet.push(...workingSet);\n            workingSet = inputSet;\n            return;\n        }\n        workingSet = runNode(workingSet, node, pointer);\n    });\n    resultingSet.push(...workingSet);\n    return resultingSet;\n}\nfunction getIterationCount(quantifier) {\n    if (quantifier == null) {\n        return 1; // default, simple group\n    }\n    if (quantifier === \"*\" || quantifier === \"+\") {\n        return Infinity;\n    }\n    const count = parseInt(quantifier);\n    return isNaN(count) ? 1 : count;\n}\nfunction pattern(data, ast, pointer) {\n    const result = [];\n    const quantifier = ast.children.find((node) => node.type === \"quantifier\");\n    const iterationCount = getIterationCount(quantifier && quantifier.text);\n    let workingSet = data;\n    if (quantifier && quantifier.text === \"*\") {\n        result.push(...workingSet);\n    }\n    let count = 0;\n    while (workingSet.length > 0 && count < iterationCount) {\n        workingSet = runPatternOnce(workingSet, ast, pointer);\n        result.push(...workingSet);\n        count += 1;\n    }\n    return result;\n}\nfunction skip(data, ast, pointer) {\n    let result = data;\n    ast.children.forEach((n) => (result = runNode(result, n, pointer)));\n    return result;\n}\nfunction runNode(data, ast, pointer) {\n    let result;\n    if (ast.type === \"query\") {\n        result = query(data, ast, pointer);\n    }\n    else if (ast.type === \"pattern\") {\n        result = pattern(data, ast, pointer);\n    }\n    else {\n        result = skip(data, ast, pointer);\n    }\n    // after each query or pattern, reset the cache, to (re)enable nested queries\n    cache.reset();\n    cache.mem.push(data);\n    return result;\n}\nexport function run(data, ast) {\n    cache.reset();\n    cache.mem.push(data);\n    return runNode([[data, null, null, \"#\"]], ast);\n}\nexport { VALUE_INDEX, KEY_INDEX, PARENT_INDEX, POINTER_INDEX };\n", "import { parse } from \"./parser\";\nimport { run, VALUE_INDEX, POINTER_INDEX } from \"./interpreter\";\nconst returnTypes = {\n    value: (r) => r.map((e) => e[VALUE_INDEX]),\n    pointer: (r) => r.map((e) => e[POINTER_INDEX]),\n    all: (r) => r,\n    map: (r) => {\n        const map = {};\n        r.forEach((e) => (map[e[POINTER_INDEX]] = e[VALUE_INDEX]));\n        return map;\n    },\n};\nexport var ReturnType;\n(function (ReturnType) {\n    ReturnType[\"POINTER\"] = \"pointer\";\n    ReturnType[\"VALUE\"] = \"value\";\n    ReturnType[\"ALL\"] = \"all\";\n    ReturnType[\"MAP\"] = \"map\";\n})(ReturnType || (ReturnType = {}));\n// export return types on function\nget.POINTER = ReturnType.POINTER;\nget.VALUE = ReturnType.VALUE;\nget.ALL = ReturnType.ALL;\nget.MAP = ReturnType.MAP;\n/**\n * Runs query on input data and returns the results\n * @param data - input data\n * @param queryString - json-query string\n * @param returnType - result format or a custom callback\n */\nexport function get(data, queryString, returnType = ReturnType.VALUE) {\n    if (queryString == null) {\n        return [];\n    }\n    queryString = queryString.replace(/(\\/$)/g, \"\");\n    if (queryString === \"\") {\n        queryString = \"#\";\n    }\n    const ast = parse(queryString);\n    if (ast == null) {\n        throw new Error(`empty ast for '${queryString}'`);\n    }\n    if (ast.rest !== \"\") {\n        throw new Error(`Failed parsing queryString from: '${ast.rest}'`);\n    }\n    const result = run(data, ast);\n    if (typeof returnType === \"function\") {\n        return result.map((r) => returnType(...r));\n    }\n    else if (returnTypes[returnType]) {\n        return returnTypes[returnType](result);\n    }\n    return result;\n}\n", "import { parse } from \"./parser\";\nconst skip = [\"root\", \"recursion\"];\nfunction buildPath(node, path = []) {\n    if (skip.includes(node.type)) {\n        node.children.forEach((n) => buildPath(n, path));\n        return path;\n    }\n    // remove escaped property quotes?\n    path.push(node.text);\n    return path;\n}\n/**\n * Returns queryString as a list of property-queries\n */\nexport function split(queryString) {\n    if (queryString == null || queryString === \"\") {\n        return [];\n    }\n    const ast = parse(queryString);\n    // console.log(toJSON(ast, null, 2));\n    return buildPath(ast);\n}\n", "import { get, ReturnType } from \"./get\";\nimport { propertyRegex } from \"./parser/jsonQueryGrammar\";\nimport { split } from \"./split\";\nconst cp = (v) => JSON.parse(JSON.stringify(v));\nconst toString = Object.prototype.toString;\nconst getType = (v) => toString\n    .call(v)\n    .match(/\\s([^\\]]+)\\]/)\n    .pop()\n    .toLowerCase();\nconst isProperty = new RegExp(`^(\"[^\"]+\"|${propertyRegex})$`);\nconst ignoreTypes = [\"string\", \"number\", \"boolean\", \"null\"];\nconst isArray = /^\\[\\d*\\]$/;\nconst arrayHasIndex = /^\\[(\\d+)\\]$/;\nconst isEscaped = /^\".+\"$/;\nconst isArrayProp = /(^\\[\\d*\\]$|^\\d+$)/;\nfunction convertToIndex(index) {\n    return parseInt(index.replace(/^(\\[|\\]$)/, \"\"));\n}\nfunction removeEscape(property) {\n    return isEscaped.test(property)\n        ? property.replace(/(^\"|\"$)/g, \"\")\n        : property;\n}\nfunction insert(array, index, value) {\n    if (array.length <= index) {\n        array[index] = value;\n    }\n    else {\n        array.splice(index, 0, value);\n    }\n}\nfunction select(workingSet, query) {\n    const nextSet = [];\n    workingSet.forEach((d) => nextSet.push(...get(d[0], query, ReturnType.ALL)));\n    return nextSet;\n}\nfunction addToArray(result, index, value, force) {\n    const target = result[0];\n    // append?\n    if (/^\\[\\]$/.test(index)) {\n        target.push(value);\n        const i = target.length - 1;\n        return [target[i], i, target, `${result[3]}/${i}}`];\n    }\n    // MERGE_ITEMS?\n    if (force == null &&\n        getType(target[index]) === \"object\" &&\n        getType(value) === \"object\") {\n        return [target[index], index, target, `${result[3]}/${index}}`];\n    }\n    if (force === set.INSERT_ITEMS ||\n        (force == null && arrayHasIndex.test(index))) {\n        const arrayIndex = convertToIndex(index);\n        insert(target, arrayIndex, value);\n        return [\n            target[arrayIndex],\n            arrayIndex,\n            target,\n            `${result[3]}/${arrayIndex}}`,\n        ];\n    }\n    if (force === set.REPLACE_ITEMS || force == null) {\n        const arrayIndex = convertToIndex(index);\n        target[arrayIndex] = value;\n        return [\n            target[arrayIndex],\n            arrayIndex,\n            target,\n            `${result[3]}/${arrayIndex}}`,\n        ];\n    }\n    throw new Error(`Unknown array index '${index}' with force-option '${force}'`);\n}\nfunction create(workingSet, query, keyIsArray, force) {\n    query = removeEscape(query);\n    return workingSet\n        .filter((o) => {\n        // replacing or inserting array\n        if (Array.isArray(o[0]) && isArrayProp.test(query)) {\n            return true;\n        }\n        return ignoreTypes.includes(getType(o[0][query])) === false;\n    })\n        .map((r) => {\n        const container = keyIsArray ? [] : {};\n        const o = r[0];\n        if (Array.isArray(o)) {\n            return addToArray(r, query, container, force);\n        }\n        o[query] = o[query] || container;\n        return [o[query], query, o, `${r[3]}/${query}`];\n    });\n}\nexport var InsertMode;\n(function (InsertMode) {\n    InsertMode[\"REPLACE_ITEMS\"] = \"replace\";\n    InsertMode[\"INSERT_ITEMS\"] = \"insert\";\n})(InsertMode || (InsertMode = {}));\n// for all array-indices within path, replace the values, ignoring insertion syntax /[1]/\nset.REPLACE_ITEMS = InsertMode.REPLACE_ITEMS;\n// for all array-indices within path, insert the values, ignoring replace syntax /1/\nset.INSERT_ITEMS = InsertMode.INSERT_ITEMS;\n// set.MERGE_ITEMS = \"merge\";\n/**\n * Runs query on input data and assigns a value to query-results.\n * @param data - input data\n * @param queryString - json-query string\n * @param value - value to assign\n * @param [force] - whether to replace or insert into arrays\n */\nexport function set(data, queryString, value, force) {\n    if (queryString == null) {\n        return cp(data);\n    }\n    queryString = queryString.replace(/(\\/$)/g, \"\");\n    if (queryString === \"\") {\n        return cp(value);\n    }\n    const result = cp(data);\n    let workingSet = [[result, null, null, \"#\"]];\n    const path = split(queryString);\n    const property = path.pop();\n    const arrayWithoutIndex = isArray.test(property) && arrayHasIndex.test(property) === false;\n    if (isProperty.test(property) === false || arrayWithoutIndex) {\n        throw new Error(`Unsupported query '${queryString}' ending with non-property`);\n    }\n    path.forEach((query, index) => {\n        if (\"__proto__\" === query ||\n            \"prototyped\" === query ||\n            \"constructor\" === query) {\n            return;\n        }\n        if (isProperty.test(query) === false) {\n            workingSet = select(workingSet, query);\n            return;\n        }\n        // process property & missing data-structure\n        const nextKey = index >= path.length - 1 ? property : path[index + 1];\n        const insertArray = isArrayProp.test(nextKey);\n        workingSet = create(workingSet, query, insertArray, force);\n    });\n    workingSet.forEach((r) => {\n        let targetValue = value;\n        if (getType(value) === \"function\") {\n            targetValue = value(r[3], property, r[0], `${r[3]}/${property}`);\n        }\n        const d = r[0];\n        if (Array.isArray(d)) {\n            addToArray(r, property, targetValue, force);\n        }\n        else {\n            const unescapedProp = removeEscape(property);\n            if (\"__proto__\" === unescapedProp ||\n                \"prototyped\" === unescapedProp ||\n                \"constructor\" === unescapedProp) {\n                return;\n            }\n            d[unescapedProp] = targetValue;\n        }\n    });\n    return result;\n}\n", "import { remove as removePointer, removeUndefinedItems, } from \"@sagold/json-pointer\";\nimport { get, ReturnType } from \"./get\";\nimport { PARENT_INDEX, POINTER_INDEX } from \"./interpreter/keys\";\n/**\n * Runs query on input data and removes matching properties from results\n * @param data - input data\n * @param queryString - json-query string\n * @param [returnRemoved] - if true, will returned removed properties, else input-data is removed\n */\nexport function remove(data, queryString, returnRemoved = false) {\n    const removed = [];\n    const matches = get(data, queryString, ReturnType.ALL);\n    matches.forEach(function (match) {\n        removed.push(match[0]);\n        removePointer(data, match[POINTER_INDEX], true);\n    });\n    matches.forEach(function (match) {\n        if (Array.isArray(match[PARENT_INDEX])) {\n            removeUndefinedItems(match[PARENT_INDEX]);\n        }\n    });\n    return returnRemoved ? removed : data;\n}\n", "const Types = {\r\n    $ref: {\r\n        type: false\r\n    },\r\n    allOf: {\r\n        type: false,\r\n        definitions: [\"allOf/*\"]\r\n    },\r\n    anyOf: {\r\n        type: false,\r\n        definitions: [\"anyOf/*\"]\r\n    },\r\n    array: {\r\n        type: true,\r\n        // ignore additionalItems:TypeDef, when items:TypeDef\r\n        definitions: [\r\n            \"allOf/*\",\r\n            \"anyOf/*\",\r\n            \"oneOf/*\",\r\n            \"not\",\r\n            \"items\",\r\n            \"items/*\",\r\n            \"additionalItems\"\r\n        ],\r\n        validationKeywords: [\"minItems\", \"maxItems\", \"uniqueItems\"],\r\n        keywords: [\"items\", \"additionalItems\", \"minItems\", \"maxItems\", \"uniqueItems\"]\r\n    },\r\n    boolean: {\r\n        type: true\r\n    },\r\n    enum: {\r\n        type: false\r\n    },\r\n    integer: {\r\n        type: true,\r\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\r\n        validationKeywords: [\"minimum\", \"maximum\", \"multipleOf\"]\r\n    },\r\n    not: {\r\n        type: false,\r\n        definitions: [\"not\"]\r\n    },\r\n    number: {\r\n        type: true,\r\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\r\n        validationKeywords: [\"minimum\", \"maximum\", \"multipleOf\"]\r\n    },\r\n    null: {\r\n        type: true\r\n    },\r\n    object: {\r\n        type: true,\r\n        // patternProperties also validate properties\r\n        // dependencies:(string, TypeDef) extend current TypeDef\r\n        // additional Properties validate only remaining properties (after properties & pattern)\r\n        definitions: [\r\n            \"allOf/*\",\r\n            \"anyOf/*\",\r\n            \"oneOf/*\",\r\n            \"not\",\r\n            \"properties/*\",\r\n            \"additionalProperties\",\r\n            \"patternProperties/*\",\r\n            \"dependencies/*\"\r\n        ],\r\n        validationKeywords: [\"minProperties\", \"maxProperties\", \"required\"],\r\n        keywords: [\r\n            \"properties\",\r\n            \"additionalProperties\",\r\n            \"patternProperties\",\r\n            \"dependencies\",\r\n            \"minProperties\",\r\n            \"maxProperties\",\r\n            \"required\"\r\n        ]\r\n    },\r\n    oneOf: {\r\n        type: false,\r\n        definitions: [\"oneOf/*\"]\r\n    },\r\n    string: {\r\n        type: true,\r\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\r\n        validationKeywords: [\"minLength\", \"maxLength\", \"pattern\"]\r\n    }\r\n};\r\nexport default Types;\r\n", "import types from \"./types\";\r\nconst isObject = (value) => Object.prototype.toString.call(value) === \"[object Object]\";\r\nconst typeKeywords = Object.keys(types).filter((id) => types[id].type === false);\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\n/**\r\n * @throws Error    on multiple matches (invalid schema)\r\n *\r\n * Returns the type id of a schema object\r\n * @param schema\r\n * @return type id, if found\r\n */\r\nexport default function getTypeId(schema) {\r\n    if (isObject(schema) === false) {\r\n        return undefined;\r\n    }\r\n    if (schema.enum) {\r\n        return \"enum\";\r\n    }\r\n    // @ts-ignore\r\n    if (types[schema.type] || Array.isArray(schema.type)) {\r\n        return schema.type;\r\n    }\r\n    const ids = typeKeywords.filter((type) => schema[type]);\r\n    if (ids.length === 1) {\r\n        return ids[0];\r\n    }\r\n    if (ids.length === 0) {\r\n        // @expensive, guess type object\r\n        for (let i = 0, l = types.object.keywords.length; i < l; i += 1) {\r\n            const keyword = types.object.keywords[i];\r\n            if (hasOwnProperty.call(schema, keyword)) {\r\n                // eslint-disable-line\r\n                return \"object\";\r\n            }\r\n        }\r\n        // @expensive, guess type array\r\n        for (let i = 0, l = types.array.keywords.length; i < l; i += 1) {\r\n            const keyword = types.array.keywords[i];\r\n            if (hasOwnProperty.call(schema, keyword)) {\r\n                // eslint-disable-line\r\n                return \"array\";\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    throw new Error(`Mutiple typeIds [${ids.join(\", \")}] matched in ${JSON.stringify(schema)}`);\r\n}\r\n", "/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\r\nconst suffixes = /(#|\\/)+$/;\r\nconst trailingHash = /#$/;\r\nconst isDomain = /^[^:]+:\\/\\/[^/]+\\//;\r\nconst trailingFragments = /\\/[^/]*$/;\r\nconst idAndPointer = /#.*$/;\r\nexport default function joinScope(previous, id) {\r\n    if (previous == null && id == null) {\r\n        return \"#\";\r\n    }\r\n    if (id == null) {\r\n        return previous.replace(trailingHash, \"\");\r\n    }\r\n    if (previous == null) {\r\n        return id.replace(trailingHash, \"\");\r\n    }\r\n    if (id[0] === \"#\") {\r\n        return `${previous.replace(idAndPointer, \"\")}${id.replace(suffixes, \"\")}`;\r\n    }\r\n    if (isDomain.test(id)) {\r\n        return id.replace(trailingHash, \"\");\r\n    }\r\n    return `${previous.replace(trailingFragments, \"\")}/${id.replace(trailingHash, \"\")}`;\r\n}\r\n", "import { get } from \"@sagold/json-pointer\";\r\nimport splitRef from \"./splitRef\";\r\nimport getTypeOf from \"../getTypeOf\";\r\nconst suffixes = /(#|\\/)+$/g;\r\nconst isObject = (val) => getTypeOf(val) === \"object\";\r\n// 1. combined is known\r\n// 2. base or pointer is known\r\n// 3. base + pointer is known\r\nexport default function getRef(context, rootSchema, $ref) {\r\n    if (isObject($ref)) {\r\n        $ref = $ref.__ref || $ref.$ref;\r\n    }\r\n    if ($ref == null) {\r\n        return rootSchema;\r\n    }\r\n    let schema;\r\n    // is it a known $ref?\r\n    const $remote = $ref.replace(suffixes, \"\");\r\n    if (context.remotes[$remote]) {\r\n        schema = context.remotes[$remote];\r\n        if (schema && schema.$ref) {\r\n            return getRef(context, rootSchema, schema.$ref);\r\n        }\r\n        return schema;\r\n    }\r\n    if (context.ids[$ref]) {\r\n        schema = get(rootSchema, context.ids[$ref]);\r\n        if (schema && schema.$ref) {\r\n            return getRef(context, rootSchema, schema.$ref);\r\n        }\r\n        return schema;\r\n    }\r\n    // is it a ref with host/pointer?\r\n    const fragments = splitRef($ref);\r\n    if (fragments.length === 0) {\r\n        return rootSchema;\r\n    }\r\n    if (fragments.length === 1) {\r\n        $ref = fragments[0];\r\n        if (context.remotes[$ref]) {\r\n            schema = context.remotes[$ref];\r\n            return getRef(context, rootSchema, schema.$ref);\r\n        }\r\n        if (context.ids[$ref]) {\r\n            schema = get(rootSchema, context.ids[$ref]);\r\n            if (schema && schema.$ref) {\r\n                return getRef(context, rootSchema, schema.$ref);\r\n            }\r\n            return schema;\r\n        }\r\n    }\r\n    if (fragments.length === 2) {\r\n        const base = fragments[0];\r\n        $ref = fragments[1];\r\n        if (context.remotes[base]) {\r\n            if (context.remotes[base].getRef) {\r\n                return context.remotes[base].getRef($ref);\r\n            }\r\n            // console.log(\"warning: uncompiled remote - context may be wrong\", base);\r\n            return getRef(context, context.remotes[base], $ref);\r\n        }\r\n        if (context.ids[base]) {\r\n            return getRef(context, get(rootSchema, context.ids[base]), $ref);\r\n        }\r\n    }\r\n    schema = get(rootSchema, context.ids[$ref] || $ref);\r\n    if (schema && schema.$ref) {\r\n        return getRef(context, rootSchema, schema.$ref);\r\n    }\r\n    return schema;\r\n}\r\n", "const suffixes = /(#|\\/)+$/g;\r\nconst emptyValues = [\"\", null, \"#\"];\r\nexport default function splitRef($ref) {\r\n    if (emptyValues.includes($ref)) {\r\n        return [];\r\n    }\r\n    $ref = $ref.replace(suffixes, \"\");\r\n    if ($ref.indexOf(\"#\") === -1) {\r\n        return [$ref.replace(suffixes, \"\")];\r\n    }\r\n    if ($ref.indexOf(\"#\") === 0) {\r\n        return [$ref.replace(suffixes, \"\")];\r\n    }\r\n    const result = $ref.split(\"#\");\r\n    result[0] = result[0].replace(suffixes, \"\");\r\n    result[1] = `#${result[1].replace(suffixes, \"\")}`;\r\n    return result;\r\n}\r\n", "import { eachSchema } from \"../../eachSchema\";\r\n// import remotes from \"../../../remotes\";\r\nimport joinScope from \"../../compile/joinScope\";\r\nimport getRef from \"../../compile/getRef\";\r\nimport { get } from \"@sagold/json-pointer\";\r\nconst COMPILED = \"__compiled\";\r\nconst COMPILED_REF = \"__ref\";\r\nconst GET_REF = \"getRef\";\r\nconst GET_ROOT = \"getRoot\";\r\nconst suffixes = /(#|\\/)+$/g;\r\n/**\r\n * @draft starting with _draft 06_ keyword `id` has been renamed to `$id`\r\n *\r\n * compiles the input root schema for $ref resolution and returns it again\r\n * @attention this modifies input schema but maintains object-structure\r\n *\r\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\r\n * this resolves a $ref target to a valid schema (for a valid $ref)\r\n *\r\n * @param rootSchema root json-schema ($id, defs, ... ) to compile\r\n * @param [force] = false force compile json-schema\r\n * @return compiled json-schema\r\n */\r\nexport default function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\r\n    // @ts-ignore\r\n    if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === undefined) {\r\n        return schemaToCompile;\r\n    }\r\n    if (schemaToCompile[COMPILED] !== undefined) {\r\n        return schemaToCompile;\r\n    } // eslint-disable-line\r\n    const context = { ids: {}, remotes: draft.remotes };\r\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\r\n    const compiledSchema = JSON.parse(rootSchemaAsString);\r\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\r\n    Object.defineProperty(compiledSchema, GET_REF, {\r\n        enumerable: false,\r\n        value: getRef.bind(null, context, compiledSchema)\r\n    });\r\n    // bail early, when no $refs are defined\r\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\r\n        return compiledSchema;\r\n    }\r\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\r\n    if (compiledSchema !== rootSchema) {\r\n        Object.defineProperty(compiledSchema, \"$defs\", {\r\n            enumerable: true,\r\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, compiledSchema.definitions, compiledSchema.$defs)\r\n        });\r\n    }\r\n    const scopes = {};\r\n    const getRoot = () => compiledSchema;\r\n    eachSchema(compiledSchema, (schema, pointer) => {\r\n        var _a;\r\n        if (schema.$id) {\r\n            // if this is a schema being merged on root object, we cannot override\r\n            // parents locations, but must reuse it\r\n            if (schema.$id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\r\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\r\n                const parentSchema = get(compiledSchema, parentPointer);\r\n                schema.$id = (_a = parentSchema.$id) !== null && _a !== void 0 ? _a : schema.$id;\r\n            }\r\n            context.ids[schema.$id.replace(suffixes, \"\")] = pointer;\r\n        }\r\n        // build up scopes and add them to $ref-resolution map\r\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\r\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\r\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\r\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\r\n        const scope = joinScope(previousScope, schema.$id);\r\n        scopes[pointer] = scope;\r\n        if (context.ids[scope] == null) {\r\n            context.ids[scope] = pointer;\r\n        }\r\n        if (schema.$ref && !schema[COMPILED_REF]) {\r\n            Object.defineProperty(schema, COMPILED_REF, {\r\n                enumerable: false,\r\n                value: joinScope(scope, schema.$ref)\r\n            });\r\n            // @todo currently not used:\r\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\r\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\r\n        }\r\n    });\r\n    return compiledSchema;\r\n}\r\n", "import getTypeOf from \"./getTypeOf\";\r\n/**\r\n * Iterates over data, retrieving its schema\r\n *\r\n * @param core - validator\r\n * @param data - the data to iterate\r\n * @param callback - will be called with (schema, data, pointer) on each item\r\n * @param [schema] - the schema matching the data. Defaults to rootSchema\r\n * @param [pointer] - pointer to current data. Default to rootPointer\r\n */\r\nexport function each(core, data, callback, schema = core.rootSchema, pointer = \"#\") {\r\n    schema = core.resolveRef(schema);\r\n    callback(schema, data, pointer);\r\n    const dataType = getTypeOf(data);\r\n    if (dataType === \"object\") {\r\n        Object.keys(data).forEach((key) => {\r\n            const nextSchema = core.step(key, schema, data, pointer); // not save\r\n            const next = data[key]; // save\r\n            core.each(next, callback, nextSchema, `${pointer}/${key}`);\r\n        });\r\n    }\r\n    else if (dataType === \"array\") {\r\n        data.forEach((next, key) => {\r\n            const nextSchema = core.step(key, schema, data, pointer);\r\n            core.each(next, callback, nextSchema, `${pointer}/${key}`);\r\n        });\r\n    }\r\n}\r\n", "/* eslint no-invalid-this: 0 */\r\nimport { createCustomError } from \"../utils/createCustomError\";\r\nconst errors = {\r\n    additionalItemsError: createCustomError(\"AdditionalItemsError\"),\r\n    additionalPropertiesError: createCustomError(\"AdditionalPropertiesError\"),\r\n    anyOfError: createCustomError(\"AnyOfError\"),\r\n    allOfError: createCustomError(\"AllOfError\"),\r\n    constError: createCustomError(\"ConstError\"),\r\n    containsError: createCustomError(\"ContainsError\"),\r\n    containsArrayError: createCustomError(\"ContainsArrayError\"),\r\n    containsAnyError: createCustomError(\"ContainsAnyError\"),\r\n    enumError: createCustomError(\"EnumError\"),\r\n    formatURLError: createCustomError(\"FormatURLError\"),\r\n    formatURIError: createCustomError(\"FormatURIError\"),\r\n    formatURIReferenceError: createCustomError(\"FormatURIReferenceError\"),\r\n    formatURITemplateError: createCustomError(\"FormatURITemplateError\"),\r\n    formatDateError: createCustomError(\"FormatDateaError\"),\r\n    formatDateTimeError: createCustomError(\"FormatDateTimeError\"),\r\n    formatEmailError: createCustomError(\"FormatEmailError\"),\r\n    formatHostnameError: createCustomError(\"FormatHostnameError\"),\r\n    formatIPV4Error: createCustomError(\"FormatIPV4Error\"),\r\n    formatIPV4LeadingZeroError: createCustomError(\"FormatIPV4LeadingZeroError\"),\r\n    formatIPV6Error: createCustomError(\"FormatIPV6Error\"),\r\n    formatIPV6LeadingZeroError: createCustomError(\"FormatIPV6LeadingZeroError\"),\r\n    formatJSONPointerError: createCustomError(\"FormatJSONPointerError\"),\r\n    formatRegExError: createCustomError(\"FormatRegExError\"),\r\n    formatTimeError: createCustomError(\"FormatTimeError\"),\r\n    invalidSchemaError: createCustomError(\"InvalidSchemaError\"),\r\n    invalidDataError: createCustomError(\"InvalidDataError\"),\r\n    invalidTypeError: createCustomError(\"InvalidTypeError\"),\r\n    invalidPropertyNameError: createCustomError(\"InvalidPropertyNameError\"),\r\n    maximumError: createCustomError(\"MaximumError\"),\r\n    maxItemsError: createCustomError(\"MaxItemsError\"),\r\n    maxLengthError: createCustomError(\"MaxLengthError\"),\r\n    maxPropertiesError: createCustomError(\"MaxPropertiesError\"),\r\n    minimumError: createCustomError(\"MinimumError\"),\r\n    minItemsError: createCustomError(\"MinItemsError\"),\r\n    minItemsOneError: createCustomError(\"MinItemsOneError\"),\r\n    minLengthError: createCustomError(\"MinLengthError\"),\r\n    minLengthOneError: createCustomError(\"MinLengthOneError\"),\r\n    minPropertiesError: createCustomError(\"MinPropertiesError\"),\r\n    missingDependencyError: createCustomError(\"MissingDependencyError\"),\r\n    missingOneOfPropertyError: createCustomError(\"MissingOneOfPropertyError\"),\r\n    multipleOfError: createCustomError(\"MultipleOfError\"),\r\n    multipleOneOfError: createCustomError(\"MultipleOneOfError\"),\r\n    noAdditionalPropertiesError: createCustomError(\"NoAdditionalPropertiesError\"),\r\n    notError: createCustomError(\"NotError\"),\r\n    oneOfError: createCustomError(\"OneOfError\"),\r\n    oneOfPropertyError: createCustomError(\"OneOfPropertyError\"),\r\n    patternError: createCustomError(\"PatternError\"),\r\n    patternPropertiesError: createCustomError(\"PatternPropertiesError\"),\r\n    requiredPropertyError: createCustomError(\"RequiredPropertyError\"),\r\n    typeError: createCustomError(\"TypeError\"),\r\n    undefinedValueError: createCustomError(\"UndefinedValueError\"),\r\n    uniqueItemsError: createCustomError(\"UniqueItemsError\"),\r\n    unknownPropertyError: createCustomError(\"UnknownPropertyError\"),\r\n    valueNotEmptyError: createCustomError(\"ValueNotEmptyError\")\r\n};\r\nexport default errors;\r\n", "/* eslint-disable max-len, no-control-regex */\r\nimport errors from \"./errors\";\r\nimport validUrl from \"valid-url\";\r\n// referenced\r\n// https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\r\n// https://gist.github.com/marcelotmelo/b67f58a08bee6c2468f8\r\nconst isValidDateTime = new RegExp(\"^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\\\.[0-9]+)?(([Zz])|([\\\\+|\\\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$\");\r\nconst isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\r\nconst isValidIPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\r\nconst isValidHostname = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/;\r\nconst matchDate = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\r\nconst matchTime = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\r\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\nconst isValidJSONPointer = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\r\nconst isValidRelativeJSONPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\r\nconst isValidURIRef = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\r\n// uri-template: https://tools.ietf.org/html/rfc6570\r\nconst isValidURITemplate = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\r\n// Default JSON-Schema formats: date-time, email, hostname, ipv4, ipv6, uri, uriref\r\nconst formatValidators = {\r\n    date: (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\") {\r\n            return undefined;\r\n        }\r\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\r\n        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\r\n        const matches = value.match(matchDate);\r\n        if (!matches) {\r\n            return errors.formatDateTimeError({ value, pointer });\r\n        }\r\n        const year = +matches[1];\r\n        const month = +matches[2];\r\n        const day = +matches[3];\r\n        // https://tools.ietf.org/html/rfc3339#appendix-C\r\n        const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\r\n        if (month >= 1 &&\r\n            month <= 12 &&\r\n            day >= 1 &&\r\n            day <= (month == 2 && isLeapYear ? 29 : DAYS[month])) {\r\n            return undefined;\r\n        }\r\n        return errors.formatDateError({ value, pointer });\r\n    },\r\n    \"date-time\": (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\") {\r\n            return undefined;\r\n        }\r\n        if (value === \"\" || isValidDateTime.test(value)) {\r\n            if (new Date(value).toString() === \"Invalid Date\") {\r\n                return errors.formatDateTimeError({ value, pointer });\r\n            }\r\n            return undefined;\r\n        }\r\n        return errors.formatDateTimeError({ value, pointer });\r\n    },\r\n    email: (core, schema, value, pointer) => {\r\n        // taken from https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\r\n        if (typeof value !== \"string\") {\r\n            return undefined;\r\n        }\r\n        if (value[0] === '\"') {\r\n            return errors.formatEmailError({ value, pointer });\r\n        }\r\n        const [name, host, ...rest] = value.split(\"@\");\r\n        if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {\r\n            return errors.formatEmailError({ value, pointer });\r\n        }\r\n        if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\")) {\r\n            return errors.formatEmailError({ value, pointer });\r\n        }\r\n        if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) {\r\n            return errors.formatEmailError({ value, pointer });\r\n        }\r\n        if (!host.split(\".\").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {\r\n            return errors.formatEmailError({ value, pointer });\r\n        }\r\n        return undefined;\r\n    },\r\n    hostname: (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\") {\r\n            return undefined;\r\n        }\r\n        if (value === \"\" || isValidHostname.test(value)) {\r\n            return undefined;\r\n        }\r\n        return errors.formatHostnameError({ value, pointer });\r\n    },\r\n    ipv4: (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            return undefined;\r\n        }\r\n        if (value && value[0] === \"0\") {\r\n            // leading zeroes should be rejected, as they are treated as octals\r\n            return errors.formatIPV4LeadingZeroError({ value, pointer });\r\n        }\r\n        if (value.length <= 15 && isValidIPV4.test(value)) {\r\n            return undefined;\r\n        }\r\n        return errors.formatIPV4Error({ value, pointer });\r\n    },\r\n    ipv6: (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            return undefined;\r\n        }\r\n        if (value && value[0] === \"0\") {\r\n            // leading zeroes should be rejected, as they are treated as octals\r\n            return errors.formatIPV6LeadingZeroError({ value, pointer });\r\n        }\r\n        if (value.length <= 45 && isValidIPV6.test(value)) {\r\n            return undefined;\r\n        }\r\n        return errors.formatIPV6Error({ value, pointer });\r\n    },\r\n    \"json-pointer\": (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            return undefined;\r\n        }\r\n        if (isValidJSONPointer.test(value)) {\r\n            return undefined;\r\n        }\r\n        return errors.formatJSONPointerError({ value, pointer });\r\n    },\r\n    \"relative-json-pointer\": (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            return undefined;\r\n        }\r\n        if (isValidRelativeJSONPointer.test(value)) {\r\n            return undefined;\r\n        }\r\n        return errors.formatJSONPointerError({ value, pointer });\r\n    },\r\n    regex: (core, schema, value, pointer) => {\r\n        if (typeof value === \"string\" && /\\\\Z$/.test(value) === false) {\r\n            try {\r\n                new RegExp(value);\r\n                return undefined;\r\n            }\r\n            catch (e) { } // eslint-disable-line no-empty\r\n            return errors.formatRegExError({ value, pointer });\r\n        }\r\n        // v7 tests, ignore non-regex values\r\n        if (typeof value === \"object\" || typeof value === \"number\" || Array.isArray(value)) {\r\n            return undefined;\r\n        }\r\n        return errors.formatRegExError({ value, pointer });\r\n    },\r\n    time: (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\") {\r\n            return undefined;\r\n        }\r\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\r\n        const matches = value.match(matchTime);\r\n        if (!matches) {\r\n            return errors.formatDateTimeError({ value, pointer });\r\n        }\r\n        const hour = +matches[1];\r\n        const minute = +matches[2];\r\n        const second = +matches[3];\r\n        const timeZone = !!matches[5];\r\n        if (((hour <= 23 && minute <= 59 && second <= 59) ||\r\n            (hour == 23 && minute == 59 && second == 60)) &&\r\n            timeZone) {\r\n            return undefined;\r\n        }\r\n        return errors.formatTimeError({ value, pointer });\r\n    },\r\n    uri: (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            return undefined;\r\n        }\r\n        if (validUrl.isUri(value)) {\r\n            return undefined;\r\n        }\r\n        return errors.formatURIError({ value, pointer });\r\n    },\r\n    \"uri-reference\": (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            return undefined;\r\n        }\r\n        if (isValidURIRef.test(value)) {\r\n            return undefined;\r\n        }\r\n        return errors.formatURIReferenceError({ value, pointer });\r\n    },\r\n    \"uri-template\": (core, schema, value, pointer) => {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            return undefined;\r\n        }\r\n        if (isValidURITemplate.test(value)) {\r\n            return undefined;\r\n        }\r\n        return errors.formatURITemplateError({ value, pointer });\r\n    },\r\n    url: (core, schema, value, pointer) => {\r\n        if (value === \"\" || validUrl.isWebUri(value)) {\r\n            return undefined;\r\n        }\r\n        return errors.formatUrlError({ value, pointer });\r\n    }\r\n};\r\nexport default formatValidators;\r\n", "import getTypeOf from \"../getTypeOf\";\r\nexport function isEmpty(v) {\r\n    const type = getTypeOf(v);\r\n    switch (type) {\r\n        case \"string\":\r\n        case \"array\":\r\n            // @ts-ignore\r\n            return v.length === 0;\r\n        case \"null\":\r\n        case \"undefined\":\r\n            return true;\r\n        case \"object\":\r\n            return Object.keys(v).length === 0;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n", "/* eslint quote-props: 0, max-statements-per-line: [\"error\", { \"max\": 2 }] */\r\nimport resolveOneOfFuzzy from \"./resolveOneOf.fuzzy\";\r\nimport getTypeOf from \"./getTypeOf\";\r\nimport merge from \"./utils/merge\";\r\nimport copy from \"./utils/copy\";\r\nimport settings from \"./config/settings\";\r\nimport { isJSONError } from \"./types\";\r\nimport { isEmpty } from \"./utils/isEmpty\";\r\nconst defaultOptions = {\r\n    addOptionalProps: true,\r\n    removeInvalidData: false\r\n};\r\nlet cache;\r\nfunction shouldResolveRef(schema, pointer) {\r\n    const { $ref } = schema;\r\n    if ($ref == null) {\r\n        return true;\r\n    }\r\n    const value = cache[pointer] == null || cache[pointer][$ref] == null ? 0 : cache[pointer][$ref];\r\n    return value < settings.GET_TEMPLATE_RECURSION_LIMIT;\r\n}\r\nfunction resolveRef(core, schema, pointer) {\r\n    // ensure we refactored consistently\r\n    if (pointer == null) {\r\n        throw new Error(`missing pointer ${pointer}`);\r\n    }\r\n    const { $ref } = schema;\r\n    if ($ref == null) {\r\n        return schema;\r\n    }\r\n    // @todo pointer + ref is redundant?\r\n    cache[pointer] = cache[pointer] || {};\r\n    cache[pointer][$ref] = cache[pointer][$ref] || 0;\r\n    cache[pointer][$ref] += 1;\r\n    return core.resolveRef(schema);\r\n}\r\nfunction convertValue(type, value) {\r\n    if (type === \"string\") {\r\n        return JSON.stringify(value);\r\n    }\r\n    else if (typeof value !== \"string\") {\r\n        return null;\r\n    }\r\n    try {\r\n        value = JSON.parse(value);\r\n        if (typeof value === type) {\r\n            return value;\r\n        }\r\n    }\r\n    catch (e) { } // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n/**\r\n * Resolves $ref, allOf and anyOf schema-options, returning a combined json-schema.\r\n * Also returns a pointer-property on schema, that must be used as current pointer.\r\n * @param core\r\n * @param schema\r\n * @param data\r\n * @param pointer\r\n * @return resolved json-schema or input-schema\r\n */\r\nfunction createTemplateSchema(core, schema, data, pointer) {\r\n    // invalid schema\r\n    if (getTypeOf(schema) !== \"object\") {\r\n        return Object.assign({ pointer }, schema);\r\n    }\r\n    // return if reached recursion limit\r\n    if (shouldResolveRef(schema, pointer) === false && data == null) {\r\n        return false;\r\n    }\r\n    // resolve $ref and copy schema\r\n    let templateSchema = copy(resolveRef(core, schema, pointer));\r\n    if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {\r\n        // test if we may resolve\r\n        if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {\r\n            const resolvedAnyOf = resolveRef(core, schema.anyOf[0], `${pointer}/anyOf/0`);\r\n            templateSchema = merge(templateSchema, resolvedAnyOf);\r\n            // add pointer return-value, if any\r\n            templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;\r\n        }\r\n        delete templateSchema.anyOf;\r\n    }\r\n    // resolve allOf\r\n    if (Array.isArray(schema.allOf)) {\r\n        for (let i = 0, l = schema.allOf.length; i < l; i += 1) {\r\n            // test if we may resolve\r\n            if (shouldResolveRef(schema.allOf[i], `${pointer}/allOf/${i}`)) {\r\n                templateSchema = merge(templateSchema, resolveRef(core, schema.allOf[i], `${pointer}/allOf/${i}`));\r\n                // add pointer return-value, if any\r\n                templateSchema.pointer = schema.allOf[i].$ref || templateSchema.pointer;\r\n            }\r\n        }\r\n        delete templateSchema.allOf;\r\n    }\r\n    templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;\r\n    return templateSchema;\r\n}\r\nconst isJSONSchema = (template) => template && typeof template === \"object\";\r\n/**\r\n * Create data object matching the given schema\r\n *\r\n * @param core - json schema core\r\n * @param [data] - optional template data\r\n * @param [schema] - json schema, defaults to rootSchema\r\n * @return created template data\r\n */\r\nfunction getTemplate(core, data, _schema, pointer, opts) {\r\n    if (_schema == null) {\r\n        throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);\r\n    }\r\n    if (pointer == null) {\r\n        throw new Error(\"Missing pointer\");\r\n    }\r\n    // resolve $ref references, allOf and first anyOf definitions\r\n    let schema = createTemplateSchema(core, _schema, data, pointer);\r\n    if (!isJSONSchema(schema)) {\r\n        return undefined;\r\n    }\r\n    pointer = schema.pointer;\r\n    if (schema === null || schema === void 0 ? void 0 : schema.const) {\r\n        return schema.const;\r\n    }\r\n    if (Array.isArray(schema.oneOf)) {\r\n        if (isEmpty(data)) {\r\n            const type = schema.oneOf[0].type ||\r\n                schema.type ||\r\n                (schema.const && typeof schema.const) ||\r\n                getTypeOf(data);\r\n            schema = { ...schema.oneOf[0], type };\r\n        }\r\n        else {\r\n            // find correct schema for data\r\n            const resolvedSchema = resolveOneOfFuzzy(core, data, schema);\r\n            if (isJSONError(resolvedSchema)) {\r\n                if (data != null && opts.removeInvalidData !== true) {\r\n                    return data;\r\n                }\r\n                // override\r\n                schema = schema.oneOf[0];\r\n                data = undefined;\r\n            }\r\n            else {\r\n                schema = resolvedSchema;\r\n            }\r\n        }\r\n    }\r\n    // @todo Array.isArray(schema.type)\r\n    // -> hasDefault? return\r\n    // if not -> pick first types\r\n    if (!isJSONSchema(schema) || schema.type == null) {\r\n        return undefined;\r\n    }\r\n    const type = Array.isArray(schema.type)\r\n        ? selectType(schema.type, data, schema.default)\r\n        : schema.type;\r\n    // reset invalid type\r\n    if (data != null && getTypeOf(data) !== type) {\r\n        data = convertValue(type, data);\r\n    }\r\n    if (TYPE[type] == null) {\r\n        // in case we could not resolve the type\r\n        // (schema-type could not be resolved and returned an error)\r\n        if (opts.removeInvalidData) {\r\n            return undefined;\r\n        }\r\n        return data;\r\n    }\r\n    const templateData = TYPE[type](core, schema, data, pointer, opts);\r\n    return templateData;\r\n}\r\nfunction selectType(types, data, defaultValue) {\r\n    if (data == undefined) {\r\n        if (defaultValue != null) {\r\n            const defaultType = getTypeOf(defaultValue);\r\n            if (types.includes(defaultType)) {\r\n                return defaultType;\r\n            }\r\n        }\r\n        return types[0];\r\n    }\r\n    const dataType = getTypeOf(data);\r\n    if (types.includes(dataType)) {\r\n        return dataType;\r\n    }\r\n    return types[0];\r\n}\r\nconst TYPE = {\r\n    null: (core, schema, data) => getDefault(schema, data, null),\r\n    string: (core, schema, data) => getDefault(schema, data, \"\"),\r\n    number: (core, schema, data) => getDefault(schema, data, 0),\r\n    integer: (core, schema, data) => getDefault(schema, data, 0),\r\n    boolean: (core, schema, data) => getDefault(schema, data, false),\r\n    object: (core, schema, data, pointer, opts) => {\r\n        var _a;\r\n        const template = schema.default === undefined ? {} : schema.default;\r\n        const d = {}; // do not assign data here, to keep ordering from json-schema\r\n        const required = (_a = schema.required) !== null && _a !== void 0 ? _a : [];\r\n        if (schema.properties) {\r\n            Object.keys(schema.properties).forEach((key) => {\r\n                const value = data == null || data[key] == null ? template[key] : data[key];\r\n                const isRequired = required.includes(key);\r\n                // Omit adding a property if it is not required or optional props should be added\r\n                if (value != null || isRequired || opts.addOptionalProps) {\r\n                    d[key] = getTemplate(core, value, schema.properties[key], `${pointer}/properties/${key}`, opts);\r\n                }\r\n            });\r\n        }\r\n        if (schema.dependencies) {\r\n            Object.keys(schema.dependencies).forEach((key) => {\r\n                if (d[key] === undefined) {\r\n                    return;\r\n                }\r\n                const dependency = schema.dependencies[key];\r\n                // dependencyRequired: { key: ['prop1', 'prop2'] }\r\n                if (Array.isArray(dependency)) {\r\n                    dependency.forEach((prop) => {\r\n                        d[prop] = getTemplate(core, d[prop], schema.properties[prop], `${pointer}/properties/${prop}`, opts);\r\n                    });\r\n                    return;\r\n                }\r\n                if (getTypeOf(dependency) !== \"object\") {\r\n                    return;\r\n                }\r\n                const result = getTemplate(core, data, {\r\n                    ...dependency,\r\n                    // required: Object.keys(dependency.properties || {}).concat(\r\n                    //     dependency.required ?? []\r\n                    // ),\r\n                    type: \"object\"\r\n                }, `${pointer}/dependencies/${key}`, opts);\r\n                if (result && !isJSONError(result)) {\r\n                    Object.assign(d, result);\r\n                }\r\n            });\r\n        }\r\n        if (data) {\r\n            // merge any missing data (additionals) to resulting object\r\n            Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));\r\n        }\r\n        if (schema.if && (schema.then || schema.else)) {\r\n            const isValid = core.isValid(d, schema.if);\r\n            if (isValid && schema.then) {\r\n                const additionalData = core.getTemplate(d, { type: \"object\", ...schema.then }, opts);\r\n                Object.assign(d, additionalData);\r\n            }\r\n            else if (!isValid && schema.else) {\r\n                const additionalData = core.getTemplate(d, { type: \"object\", ...schema.else }, opts);\r\n                Object.assign(d, additionalData);\r\n            }\r\n        }\r\n        // returns object, which is ordered by json-schema\r\n        return d;\r\n    },\r\n    // build array type of items, ignores additionalItems\r\n    array: (core, schema, data, pointer, opts) => {\r\n        var _a, _b, _c;\r\n        const template = schema.default === undefined ? [] : schema.default;\r\n        schema.minItems = schema.minItems || 0;\r\n        const d = data || [];\r\n        // items are undefined\r\n        if (schema.items == null) {\r\n            return d;\r\n        }\r\n        // build defined set of items\r\n        if (Array.isArray(schema.items)) {\r\n            for (let i = 0, l = Math.max((_a = schema.minItems) !== null && _a !== void 0 ? _a : 0, (_c = (_b = schema.items) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0); i < l; i += 1) {\r\n                d[i] = getTemplate(core, d[i] == null ? template[i] : d[i], schema.items[i], `${pointer}/items/${i}`, opts);\r\n            }\r\n            return d;\r\n        }\r\n        // abort if the schema is invalid\r\n        if (getTypeOf(schema.items) !== \"object\") {\r\n            return d;\r\n        }\r\n        // resolve allOf and first anyOf definition\r\n        const templateSchema = createTemplateSchema(core, schema.items, data, pointer);\r\n        if (templateSchema === false) {\r\n            return d;\r\n        }\r\n        pointer = templateSchema.pointer || pointer;\r\n        // build oneOf\r\n        if (templateSchema.oneOf && d.length === 0) {\r\n            const oneOfSchema = templateSchema.oneOf[0];\r\n            for (let i = 0; i < schema.minItems; i += 1) {\r\n                d[i] = getTemplate(core, d[i] == null ? template[i] : d[i], oneOfSchema, `${pointer}/oneOf/0`, opts);\r\n            }\r\n            return d;\r\n        }\r\n        if (templateSchema.oneOf && d.length > 0) {\r\n            const itemCount = Math.max(schema.minItems, d.length);\r\n            for (let i = 0; i < itemCount; i += 1) {\r\n                let value = d[i] == null ? template[i] : d[i];\r\n                let one = resolveOneOfFuzzy(core, value, templateSchema);\r\n                if (one == null || isJSONError(one)) {\r\n                    // schema could not be resolved or data is invalid\r\n                    if (value != null && opts.removeInvalidData !== true) {\r\n                        // keep invalid value\r\n                        d[i] = value;\r\n                    }\r\n                    else {\r\n                        // replace invalid value\r\n                        value = undefined;\r\n                        one = templateSchema.oneOf[0];\r\n                        d[i] = getTemplate(core, value, one, `${pointer}/oneOf/${i}`, opts);\r\n                    }\r\n                }\r\n                else {\r\n                    // schema is valid\r\n                    d[i] = getTemplate(core, value, one, `${pointer}/oneOf/${i}`, opts);\r\n                }\r\n            }\r\n            return d;\r\n        }\r\n        // build items-definition\r\n        if (templateSchema.type) {\r\n            for (let i = 0, l = Math.max(schema.minItems, d.length); i < l; i += 1) {\r\n                d[i] = getTemplate(core, d[i] == null ? template[i] : d[i], templateSchema, `${pointer}/items`, opts);\r\n            }\r\n            return d;\r\n        }\r\n        return d;\r\n    }\r\n};\r\nfunction getDefault(schema, templateValue, initValue) {\r\n    if (templateValue != null) {\r\n        return templateValue;\r\n    }\r\n    else if (schema.const) {\r\n        return schema.const;\r\n    }\r\n    else if (schema.default === undefined && Array.isArray(schema.enum)) {\r\n        return schema.enum[0];\r\n    }\r\n    else if (schema.default === undefined) {\r\n        return initValue;\r\n    }\r\n    return schema.default;\r\n}\r\nexport default (core, data, schema = core.rootSchema, opts = defaultOptions) => {\r\n    cache = { mi: {} };\r\n    return getTemplate(core, data, schema, \"#\", opts);\r\n};\r\n", "/**\r\n * Test if the data is valid according to the given schema\r\n *\r\n * @param core - validator\r\n * @param value - value to validate\r\n * @param [schema] - json schema\r\n * @param [pointer] - json pointer pointing to value\r\n * @return if schema does match given value\r\n */\r\nexport default function isValid(core, value, schema = core.rootSchema, pointer = \"#\") {\r\n    return core.validate(value, schema, pointer).length === 0;\r\n}\r\n", "/**\r\n * deep comparison of javascript types. Better handling than using\r\n * JSON.stringify, where property order is accounted for\r\n *\r\n * @returns true, if data types are deep equal\r\n */\r\nexport default function deepCompareStrict(a, b) {\r\n    const typeofa = typeof a;\r\n    if (typeofa !== typeof b) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(a)) {\r\n        if (!Array.isArray(b)) {\r\n            return false;\r\n        }\r\n        const length = a.length;\r\n        if (length !== b.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < length; i++) {\r\n            if (!deepCompareStrict(a[i], b[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    if (typeofa === \"object\") {\r\n        if (!a || !b) {\r\n            return a === b;\r\n        }\r\n        const aKeys = Object.keys(a);\r\n        const bKeys = Object.keys(b);\r\n        const length = aKeys.length;\r\n        if (length !== bKeys.length) {\r\n            return false;\r\n        }\r\n        for (const k of aKeys) {\r\n            if (!deepCompareStrict(a[k], b[k])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return a === b;\r\n}\r\n", "/* eslint no-bitwise: 0 */\r\n/**\r\n * taken from punycode@2.1.0\r\n *\r\n * Creates an array containing the numeric code points of each Unicode\r\n * character in the string. While JavaScript uses UCS-2 internally,\r\n * this function will convert a pair of surrogate halves (each of which\r\n * UCS-2 exposes as separate characters) into a single code point,\r\n * matching UTF-16.\r\n * @see `punycode.ucs2.encode`\r\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n * @memberOf punycode.ucs2\r\n * @name decode\r\n * @param string The Unicode input string (UCS-2).\r\n * @returns The new array of code points.\r\n */\r\nexport default function ucs2decode(string) {\r\n    const output = [];\r\n    let counter = 0;\r\n    const length = string.length;\r\n    while (counter < length) {\r\n        const value = string.charCodeAt(counter++);\r\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\r\n            // It's a high surrogate, and there is a next character.\r\n            const extra = string.charCodeAt(counter++);\r\n            // eslint-disable-next-line eqeqeq\r\n            if ((extra & 0xfc00) == 0xdc00) {\r\n                // Low surrogate.\r\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\r\n            }\r\n            else {\r\n                // It's an unmatched surrogate; only append this code unit, in case the\r\n                // next code unit is the high surrogate of a surrogate pair.\r\n                output.push(value);\r\n                counter--;\r\n            }\r\n        }\r\n        else {\r\n            output.push(value);\r\n        }\r\n    }\r\n    return output;\r\n}\r\n", "import getTypeOf from \"../getTypeOf\";\r\nimport isSame from \"../utils/deepCompare\";\r\nimport settings from \"../config/settings\";\r\nimport ucs2decode from \"../utils/punycode.ucs2decode\";\r\nimport { isJSONError } from \"../types\";\r\nconst FPP = settings.floatingPointPrecision;\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasProperty = (value, property) => !(value[property] === undefined || !hasOwnProperty.call(value, property));\r\n// list of validation keywords: http://json-schema.org/latest/json-schema-validation.html#rfc.section.5\r\nconst KeywordValidation = {\r\n    additionalProperties: (core, schema, value, pointer) => {\r\n        if (schema.additionalProperties === true || schema.additionalProperties == null) {\r\n            return undefined;\r\n        }\r\n        if (getTypeOf(schema.patternProperties) === \"object\" &&\r\n            schema.additionalProperties === false) {\r\n            // this is an arrangement with patternProperties. patternProperties validate before additionalProperties:\r\n            // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#index-5\r\n            return undefined;\r\n        }\r\n        const errors = [];\r\n        let receivedProperties = Object.keys(value).filter((prop) => settings.propertyBlacklist.includes(prop) === false);\r\n        const expectedProperties = Object.keys(schema.properties || {});\r\n        if (getTypeOf(schema.patternProperties) === \"object\") {\r\n            // filter received properties by matching patternProperties\r\n            const patterns = Object.keys(schema.patternProperties).map((pattern) => new RegExp(pattern));\r\n            receivedProperties = receivedProperties.filter((prop) => {\r\n                for (let i = 0; i < patterns.length; i += 1) {\r\n                    if (patterns[i].test(prop)) {\r\n                        return false; // remove\r\n                    }\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        // adds an error for each an unexpected property\r\n        for (let i = 0, l = receivedProperties.length; i < l; i += 1) {\r\n            const property = receivedProperties[i];\r\n            if (expectedProperties.indexOf(property) === -1) {\r\n                const isObject = typeof schema.additionalProperties === \"object\";\r\n                // additionalProperties { oneOf: [] }\r\n                if (isObject && Array.isArray(schema.additionalProperties.oneOf)) {\r\n                    const result = core.resolveOneOf(value[property], schema.additionalProperties, `${pointer}/${property}`);\r\n                    if (isJSONError(result)) {\r\n                        errors.push(core.errors.additionalPropertiesError({\r\n                            schema: schema.additionalProperties,\r\n                            property: receivedProperties[i],\r\n                            properties: expectedProperties,\r\n                            pointer,\r\n                            // pass all validation errors\r\n                            errors: result.data.errors\r\n                        }));\r\n                    }\r\n                    else {\r\n                        errors.push(...core.validate(value[property], result, pointer));\r\n                    }\r\n                    // additionalProperties {}\r\n                }\r\n                else if (isObject) {\r\n                    errors.push(...core.validate(value[property], schema.additionalProperties, `${pointer}/${property}`));\r\n                }\r\n                else {\r\n                    errors.push(core.errors.noAdditionalPropertiesError({\r\n                        property: receivedProperties[i],\r\n                        properties: expectedProperties,\r\n                        pointer\r\n                    }));\r\n                }\r\n            }\r\n        }\r\n        return errors;\r\n    },\r\n    allOf: (core, schema, value, pointer) => {\r\n        if (Array.isArray(schema.allOf) === false) {\r\n            return undefined;\r\n        }\r\n        const errors = [];\r\n        schema.allOf.forEach((subSchema) => {\r\n            errors.push(...core.validate(value, subSchema, pointer));\r\n        });\r\n        return errors;\r\n    },\r\n    anyOf: (core, schema, value, pointer) => {\r\n        if (Array.isArray(schema.anyOf) === false) {\r\n            return undefined;\r\n        }\r\n        for (let i = 0; i < schema.anyOf.length; i += 1) {\r\n            if (core.isValid(value, schema.anyOf[i])) {\r\n                return undefined;\r\n            }\r\n        }\r\n        return core.errors.anyOfError({ anyOf: schema.anyOf, value, pointer });\r\n    },\r\n    dependencies: (core, schema, value, pointer) => {\r\n        if (getTypeOf(schema.dependencies) !== \"object\") {\r\n            return undefined;\r\n        }\r\n        const errors = [];\r\n        Object.keys(value).forEach((property) => {\r\n            if (schema.dependencies[property] === undefined) {\r\n                return;\r\n            }\r\n            // @draft >= 6 boolean schema\r\n            if (schema.dependencies[property] === true) {\r\n                return;\r\n            }\r\n            if (schema.dependencies[property] === false) {\r\n                errors.push(core.errors.missingDependencyError({ pointer }));\r\n                return;\r\n            }\r\n            let dependencyErrors;\r\n            const type = getTypeOf(schema.dependencies[property]);\r\n            if (type === \"array\") {\r\n                dependencyErrors = schema.dependencies[property]\r\n                    .filter((dependency) => value[dependency] === undefined)\r\n                    .map((missingProperty) => core.errors.missingDependencyError({ missingProperty, pointer }));\r\n            }\r\n            else if (type === \"object\") {\r\n                dependencyErrors = core.validate(value, schema.dependencies[property], pointer);\r\n            }\r\n            else {\r\n                throw new Error(`Invalid dependency definition for ${pointer}/${property}. Must be list or schema`);\r\n            }\r\n            errors.push(...dependencyErrors);\r\n        });\r\n        return errors.length > 0 ? errors : undefined;\r\n    },\r\n    enum: (core, schema, value, pointer) => {\r\n        const type = getTypeOf(value);\r\n        if (type === \"object\" || type === \"array\") {\r\n            const valueStr = JSON.stringify(value);\r\n            for (let i = 0; i < schema.enum.length; i += 1) {\r\n                if (JSON.stringify(schema.enum[i]) === valueStr) {\r\n                    return undefined;\r\n                }\r\n            }\r\n        }\r\n        else if (schema.enum.includes(value)) {\r\n            return undefined;\r\n        }\r\n        return core.errors.enumError({ values: schema.enum, value, pointer });\r\n    },\r\n    format: (core, schema, value, pointer) => {\r\n        if (core.validateFormat[schema.format]) {\r\n            const errors = core.validateFormat[schema.format](core, schema, value, pointer);\r\n            return errors;\r\n        }\r\n        // fail silently if given format is not defined\r\n        return undefined;\r\n    },\r\n    items: (core, schema, value, pointer) => {\r\n        // @draft >= 7 bool schema\r\n        if (schema.items === false) {\r\n            if (Array.isArray(value) && value.length === 0) {\r\n                return undefined;\r\n            }\r\n            return core.errors.invalidDataError({ pointer, value });\r\n        }\r\n        const errors = [];\r\n        for (let i = 0; i < value.length; i += 1) {\r\n            const itemData = value[i];\r\n            // @todo reevaluate: incomplete schema is created here\r\n            const itemSchema = core.step(i, schema, value, pointer);\r\n            if (isJSONError(itemSchema)) {\r\n                return [itemSchema];\r\n            }\r\n            const itemErrors = core.validate(itemData, itemSchema, `${pointer}/${i}`);\r\n            errors.push(...itemErrors);\r\n        }\r\n        return errors;\r\n    },\r\n    maximum: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.maximum)) {\r\n            return undefined;\r\n        }\r\n        if (schema.maximum && schema.maximum < value) {\r\n            return core.errors.maximumError({ maximum: schema.maximum, length: value, pointer });\r\n        }\r\n        if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {\r\n            return core.errors.maximumError({ maximum: schema.maximum, length: value, pointer });\r\n        }\r\n        return undefined;\r\n    },\r\n    maxItems: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.maxItems)) {\r\n            return undefined;\r\n        }\r\n        if (schema.maxItems < value.length) {\r\n            return core.errors.maxItemsError({\r\n                maximum: schema.maxItems,\r\n                length: value.length,\r\n                pointer\r\n            });\r\n        }\r\n        return undefined;\r\n    },\r\n    maxLength: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.maxLength)) {\r\n            return undefined;\r\n        }\r\n        const lengthOfString = ucs2decode(value).length;\r\n        if (schema.maxLength < lengthOfString) {\r\n            return core.errors.maxLengthError({\r\n                maxLength: schema.maxLength,\r\n                length: lengthOfString,\r\n                pointer\r\n            });\r\n        }\r\n        return undefined;\r\n    },\r\n    maxProperties: (core, schema, value, pointer) => {\r\n        const propertyCount = Object.keys(value).length;\r\n        if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {\r\n            return core.errors.maxPropertiesError({\r\n                maxProperties: schema.maxProperties,\r\n                length: propertyCount,\r\n                pointer\r\n            });\r\n        }\r\n        return undefined;\r\n    },\r\n    minLength: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.minLength)) {\r\n            return undefined;\r\n        }\r\n        const lengthOfString = ucs2decode(value).length;\r\n        if (schema.minLength > lengthOfString) {\r\n            if (schema.minLength === 1) {\r\n                return core.errors.minLengthOneError({\r\n                    minLength: schema.minLength,\r\n                    length: lengthOfString,\r\n                    pointer\r\n                });\r\n            }\r\n            return core.errors.minLengthError({\r\n                minLength: schema.minLength,\r\n                length: lengthOfString,\r\n                pointer\r\n            });\r\n        }\r\n        return undefined;\r\n    },\r\n    minimum: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.minimum)) {\r\n            return undefined;\r\n        }\r\n        if (schema.minimum > value) {\r\n            return core.errors.minimumError({ minimum: schema.minimum, length: value, pointer });\r\n        }\r\n        if (schema.exclusiveMinimum === true && schema.minimum === value) {\r\n            return core.errors.minimumError({ minimum: schema.minimum, length: value, pointer });\r\n        }\r\n        return undefined;\r\n    },\r\n    minItems: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.minItems)) {\r\n            return undefined;\r\n        }\r\n        if (schema.minItems > value.length) {\r\n            if (schema.minItems === 1) {\r\n                return core.errors.minItemsOneError({\r\n                    minItems: schema.minItems,\r\n                    length: value.length,\r\n                    pointer\r\n                });\r\n            }\r\n            return core.errors.minItemsError({\r\n                minItems: schema.minItems,\r\n                length: value.length,\r\n                pointer\r\n            });\r\n        }\r\n        return undefined;\r\n    },\r\n    minProperties: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.minProperties)) {\r\n            return undefined;\r\n        }\r\n        const propertyCount = Object.keys(value).length;\r\n        if (schema.minProperties > propertyCount) {\r\n            return core.errors.minPropertiesError({\r\n                minProperties: schema.minProperties,\r\n                length: propertyCount,\r\n                pointer\r\n            });\r\n        }\r\n        return undefined;\r\n    },\r\n    multipleOf: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.multipleOf)) {\r\n            return undefined;\r\n        }\r\n        // https://github.com/cfworker/cfworker/blob/master/packages/json-schema/src/validate.ts#L1061\r\n        // https://github.com/ExodusMovement/schemasafe/blob/master/src/compile.js#L441\r\n        if (((value * FPP) % (schema.multipleOf * FPP)) / FPP !== 0) {\r\n            return core.errors.multipleOfError({ multipleOf: schema.multipleOf, value, pointer });\r\n        }\r\n        // also check https://stackoverflow.com/questions/1815367/catch-and-compute-overflow-during-multiplication-of-two-large-integers\r\n        return undefined;\r\n    },\r\n    not: (core, schema, value, pointer) => {\r\n        const errors = [];\r\n        if (core.validate(value, schema.not, pointer).length === 0) {\r\n            errors.push(core.errors.notError({ value, not: schema.not, pointer }));\r\n        }\r\n        return errors;\r\n    },\r\n    oneOf: (core, schema, value, pointer) => {\r\n        if (Array.isArray(schema.oneOf) === false) {\r\n            return undefined;\r\n        }\r\n        schema = core.resolveOneOf(value, schema, pointer);\r\n        if (isJSONError(schema)) {\r\n            return schema;\r\n        }\r\n        return undefined;\r\n    },\r\n    pattern: (core, schema, value, pointer) => {\r\n        const pattern = new RegExp(schema.pattern, \"u\");\r\n        if (pattern.test(value) === false) {\r\n            return core.errors.patternError({\r\n                pattern: schema.pattern,\r\n                description: schema.patternExample || schema.pattern,\r\n                received: value,\r\n                pointer\r\n            });\r\n        }\r\n        return undefined;\r\n    },\r\n    patternProperties: (core, schema, value, pointer) => {\r\n        const properties = schema.properties || {};\r\n        const pp = schema.patternProperties;\r\n        if (getTypeOf(pp) !== \"object\") {\r\n            return undefined;\r\n        }\r\n        const errors = [];\r\n        const keys = Object.keys(value);\r\n        const patterns = Object.keys(pp).map((expr) => ({\r\n            regex: new RegExp(expr),\r\n            patternSchema: pp[expr]\r\n        }));\r\n        keys.forEach((key) => {\r\n            let patternFound = false;\r\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\r\n                if (patterns[i].regex.test(key)) {\r\n                    patternFound = true;\r\n                    const valErrors = core.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);\r\n                    if (valErrors && valErrors.length > 0) {\r\n                        errors.push(...valErrors);\r\n                    }\r\n                }\r\n            }\r\n            if (properties[key]) {\r\n                return;\r\n            }\r\n            if (patternFound === false && schema.additionalProperties === false) {\r\n                // this is an arrangement with additionalProperties\r\n                errors.push(core.errors.patternPropertiesError({\r\n                    key,\r\n                    pointer,\r\n                    patterns: Object.keys(pp).join(\",\")\r\n                }));\r\n            }\r\n        });\r\n        return errors;\r\n    },\r\n    properties: (core, schema, value, pointer) => {\r\n        const errors = [];\r\n        const keys = Object.keys(schema.properties || {});\r\n        for (let i = 0; i < keys.length; i += 1) {\r\n            const key = keys[i];\r\n            if (hasProperty(value, key)) {\r\n                const itemSchema = core.step(key, schema, value, pointer);\r\n                const keyErrors = core.validate(value[key], itemSchema, `${pointer}/${key}`);\r\n                errors.push(...keyErrors);\r\n            }\r\n        }\r\n        return errors;\r\n    },\r\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword\r\n    propertiesRequired: (core, schema, value, pointer) => {\r\n        const errors = [];\r\n        const keys = Object.keys(schema.properties || {});\r\n        for (let i = 0; i < keys.length; i += 1) {\r\n            const key = keys[i];\r\n            if (value[key] === undefined) {\r\n                errors.push(core.errors.requiredPropertyError({ key, pointer }));\r\n            }\r\n            else {\r\n                const itemSchema = core.step(key, schema, value, pointer);\r\n                const keyErrors = core.validate(value[key], itemSchema, `${pointer}/${key}`);\r\n                errors.push(...keyErrors);\r\n            }\r\n        }\r\n        return errors;\r\n    },\r\n    required: (core, schema, value, pointer) => {\r\n        if (Array.isArray(schema.required) === false) {\r\n            return undefined;\r\n        }\r\n        return schema.required.map((property) => {\r\n            if (!hasProperty(value, property)) {\r\n                return core.errors.requiredPropertyError({ key: property, pointer });\r\n            }\r\n            return undefined;\r\n        });\r\n    },\r\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword\r\n    requiredNotEmpty: (core, schema, value, pointer) => {\r\n        if (Array.isArray(schema.required) === false) {\r\n            return undefined;\r\n        }\r\n        return schema.required.map((property) => {\r\n            if (value[property] == null || value[property] === \"\") {\r\n                return core.errors.valueNotEmptyError({\r\n                    property,\r\n                    pointer: `${pointer}/${property}`\r\n                });\r\n            }\r\n            return undefined;\r\n        });\r\n    },\r\n    uniqueItems: (core, schema, value, pointer) => {\r\n        if ((Array.isArray(value) && schema.uniqueItems) === false) {\r\n            return undefined;\r\n        }\r\n        const errors = [];\r\n        value.forEach((item, index) => {\r\n            for (let i = index + 1; i < value.length; i += 1) {\r\n                if (isSame(item, value[i])) {\r\n                    errors.push(core.errors.uniqueItemsError({\r\n                        pointer,\r\n                        itemPointer: `${pointer}/${index}`,\r\n                        duplicatePointer: `${pointer}/${i}`,\r\n                        value: JSON.stringify(item)\r\n                    }));\r\n                }\r\n            }\r\n        });\r\n        return errors;\r\n    }\r\n};\r\nexport default KeywordValidation;\r\n", "import Keywords from \"../../validation/keyword\";\r\nimport getTypeOf from \"../../getTypeOf\";\r\nconst KeywordValidation = {\r\n    ...Keywords,\r\n    // @draft >= 6\r\n    contains: (core, schema, value, pointer) => {\r\n        if (schema.contains === false) {\r\n            return core.errors.containsArrayError({ pointer, value });\r\n        }\r\n        if (schema.contains === true) {\r\n            if (Array.isArray(value) && value.length === 0) {\r\n                return core.errors.containsAnyError({ pointer });\r\n            }\r\n            return undefined;\r\n        }\r\n        if (getTypeOf(schema.contains) !== \"object\") {\r\n            // ignore invalid schema\r\n            return undefined;\r\n        }\r\n        for (let i = 0; i < value.length; i += 1) {\r\n            if (core.isValid(value[i], schema.contains)) {\r\n                return undefined;\r\n            }\r\n        }\r\n        return core.errors.containsError({ pointer, schema: JSON.stringify(schema.contains) });\r\n    },\r\n    exclusiveMaximum: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.exclusiveMaximum)) {\r\n            return undefined;\r\n        }\r\n        if (schema.exclusiveMaximum <= value) {\r\n            return core.errors.maximumError({\r\n                maximum: schema.exclusiveMaximum,\r\n                length: value,\r\n                pointer\r\n            });\r\n        }\r\n        return undefined;\r\n    },\r\n    exclusiveMinimum: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.exclusiveMinimum)) {\r\n            return undefined;\r\n        }\r\n        if (schema.exclusiveMinimum >= value) {\r\n            return core.errors.minimumError({\r\n                minimum: schema.exclusiveMinimum,\r\n                length: value,\r\n                pointer\r\n            });\r\n        }\r\n        return undefined;\r\n    },\r\n    if: (core, schema, value, pointer) => {\r\n        if (schema.if == null) {\r\n            return undefined;\r\n        }\r\n        const ifErrors = core.validate(value, schema.if, pointer);\r\n        // console.log(\"if Errors\", value, ifErrors);\r\n        if (ifErrors.length === 0 && schema.then) {\r\n            return core.validate(value, schema.then, pointer);\r\n        }\r\n        if (ifErrors.length !== 0 && schema.else) {\r\n            return core.validate(value, schema.else, pointer);\r\n        }\r\n    },\r\n    maximum: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.maximum)) {\r\n            return undefined;\r\n        }\r\n        if (schema.maximum && schema.maximum < value) {\r\n            return core.errors.maximumError({ maximum: schema.maximum, length: value, pointer });\r\n        }\r\n        return undefined;\r\n    },\r\n    minimum: (core, schema, value, pointer) => {\r\n        if (isNaN(schema.minimum)) {\r\n            return undefined;\r\n        }\r\n        if (schema.minimum > value) {\r\n            return core.errors.minimumError({ minimum: schema.minimum, length: value, pointer });\r\n        }\r\n        return undefined;\r\n    },\r\n    patternProperties: (core, schema, value, pointer) => {\r\n        const properties = schema.properties || {};\r\n        const pp = schema.patternProperties;\r\n        if (getTypeOf(pp) !== \"object\") {\r\n            return undefined;\r\n        }\r\n        const errors = [];\r\n        const keys = Object.keys(value);\r\n        const patterns = Object.keys(pp).map((expr) => ({\r\n            regex: new RegExp(expr),\r\n            patternSchema: pp[expr]\r\n        }));\r\n        keys.forEach((key) => {\r\n            let patternFound = false;\r\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\r\n                if (patterns[i].regex.test(key)) {\r\n                    patternFound = true;\r\n                    // for a boolean schema `false`, always invalidate\r\n                    if (patterns[i].patternSchema === false) {\r\n                        errors.push(core.errors.patternPropertiesError({\r\n                            key,\r\n                            pointer,\r\n                            patterns: Object.keys(pp).join(\",\")\r\n                        }));\r\n                        return;\r\n                    }\r\n                    const valErrors = core.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);\r\n                    if (valErrors && valErrors.length > 0) {\r\n                        errors.push(...valErrors);\r\n                    }\r\n                }\r\n            }\r\n            if (properties[key]) {\r\n                return;\r\n            }\r\n            if (patternFound === false && schema.additionalProperties === false) {\r\n                // this is an arrangement with additionalProperties\r\n                errors.push(core.errors.patternPropertiesError({\r\n                    key,\r\n                    pointer,\r\n                    patterns: Object.keys(pp).join(\",\")\r\n                }));\r\n            }\r\n        });\r\n        return errors;\r\n    },\r\n    // @draft >= 6\r\n    propertyNames: (core, schema, value, pointer) => {\r\n        // bool schema\r\n        if (schema.propertyNames === false) {\r\n            // empty objects are valid\r\n            if (Object.keys(value).length === 0) {\r\n                return undefined;\r\n            }\r\n            return core.errors.invalidPropertyNameError({\r\n                property: Object.keys(value),\r\n                pointer,\r\n                value\r\n            });\r\n        }\r\n        if (schema.propertyNames === true) {\r\n            return undefined;\r\n        }\r\n        if (getTypeOf(schema.propertyNames) !== \"object\") {\r\n            // ignore invalid schema\r\n            return undefined;\r\n        }\r\n        const errors = [];\r\n        const properties = Object.keys(value);\r\n        const propertySchema = { ...schema.propertyNames, type: \"string\" };\r\n        properties.forEach((prop) => {\r\n            const validationResult = core.validate(prop, propertySchema, `${pointer}/${prop}`);\r\n            if (validationResult.length > 0) {\r\n                errors.push(core.errors.invalidPropertyNameError({\r\n                    property: prop,\r\n                    pointer,\r\n                    validationError: validationResult[0],\r\n                    value: value[prop]\r\n                }));\r\n            }\r\n        });\r\n        return errors;\r\n    }\r\n};\r\nexport default KeywordValidation;\r\n", "import copy from \"./utils/copy\";\r\nimport merge from \"./utils/merge\";\r\nimport errors from \"./validation/errors\";\r\nexport default function resolveAnyOf(core, data, schema = core.rootSchema, pointer = \"#\") {\r\n    let found = false;\r\n    let mergedSchema = copy(schema);\r\n    for (let i = 0; i < schema.anyOf.length; i += 1) {\r\n        const anyOfSchema = core.resolveRef(schema.anyOf[i]);\r\n        if (core.isValid(data, schema.anyOf[i], pointer)) {\r\n            found = true;\r\n            mergedSchema = merge(mergedSchema, anyOfSchema);\r\n        }\r\n    }\r\n    if (found === false) {\r\n        return errors.anyOfError({ value: data, pointer, anyOf: JSON.stringify(schema.anyOf) });\r\n    }\r\n    delete mergedSchema.anyOf;\r\n    return mergedSchema;\r\n}\r\n", "import getTypeOf from \"./getTypeOf\";\r\n/**\r\n * Create a simple json schema for the given input data\r\n * @param  data - data to get json schema for\r\n * @return schema\r\n */\r\nexport default function createSchemaOf(data) {\r\n    const schema = {\r\n        type: getTypeOf(data)\r\n    };\r\n    if (schema.type === \"object\") {\r\n        schema.properties = {};\r\n        Object.keys(data).forEach((key) => (schema.properties[key] = createSchemaOf(data[key])));\r\n    }\r\n    if (schema.type === \"array\" && data.length === 1) {\r\n        schema.items = createSchemaOf(data[0]);\r\n    }\r\n    else if (schema.type === \"array\") {\r\n        schema.items = data.map(createSchemaOf);\r\n    }\r\n    return schema;\r\n}\r\n", "import { isJSONError } from \"./types\";\r\n/**\r\n * Returns a list of possible child-schemas for the given property key. In case of a oneOf selection, multiple schemas\r\n * could be added at the given property (e.g. item-index), thus an array of options is returned. In all other cases\r\n * a list with a single item will be returned\r\n *\r\n * @param core        - core to use\r\n * @param property    - parent schema of following property\r\n * @param [schema]    - parent schema of following property\r\n * @return\r\n */\r\nexport default function getChildSchemaSelection(core, property, schema = core.rootSchema) {\r\n    const result = core.step(property, schema, {}, \"#\");\r\n    if (isJSONError(result)) {\r\n        if (result.code === \"one-of-error\") {\r\n            return result.data.oneOf.map((item) => core.resolveRef(item));\r\n        }\r\n        return result;\r\n    }\r\n    return [result];\r\n}\r\n", "import getTypeOf from \"./getTypeOf\";\r\nimport createSchemaOf from \"./createSchemaOf\";\r\nimport errors from \"./validation/errors\";\r\nimport merge from \"./utils/merge\";\r\nimport { isJSONError } from \"./types\";\r\nconst stepType = {\r\n    array: (core, key, schema, data, pointer) => {\r\n        const itemsType = getTypeOf(schema.items);\r\n        if (itemsType === \"object\") {\r\n            // oneOf\r\n            if (Array.isArray(schema.items.oneOf)) {\r\n                return core.resolveOneOf(data[key], schema.items, pointer);\r\n            }\r\n            // anyOf\r\n            if (Array.isArray(schema.items.anyOf)) {\r\n                // schema of current object\r\n                return core.resolveAnyOf(data[key], schema.items, pointer);\r\n            }\r\n            // allOf\r\n            if (Array.isArray(schema.items.allOf)) {\r\n                return core.resolveAllOf(data[key], schema.items, pointer);\r\n            }\r\n            // spec: ignore additionalItems, when items is schema-object\r\n            return core.resolveRef(schema.items);\r\n        }\r\n        if (itemsType === \"array\") {\r\n            // @draft >= 7 bool schema, items:[true, false]\r\n            if (schema.items[key] === true) {\r\n                return createSchemaOf(data[key]);\r\n            }\r\n            // @draft >= 7 bool schema, items:[true, false]\r\n            if (schema.items[key] === false) {\r\n                return errors.invalidDataError({\r\n                    key,\r\n                    value: data[key],\r\n                    pointer\r\n                });\r\n            }\r\n            if (schema.items[key]) {\r\n                return core.resolveRef(schema.items[key]);\r\n            }\r\n            if (schema.additionalItems === false) {\r\n                return errors.additionalItemsError({\r\n                    key,\r\n                    value: data[key],\r\n                    pointer\r\n                });\r\n            }\r\n            if (schema.additionalItems === true || schema.additionalItems === undefined) {\r\n                return createSchemaOf(data[key]);\r\n            }\r\n            if (getTypeOf(schema.additionalItems) === \"object\") {\r\n                return schema.additionalItems;\r\n            }\r\n            throw new Error(`Invalid schema ${JSON.stringify(schema, null, 4)} for ${JSON.stringify(data, null, 4)}`);\r\n        }\r\n        if (schema.additionalItems !== false && data[key]) {\r\n            // @todo reevaluate: incomplete schema is created here\r\n            // @todo support additionalItems: {schema}\r\n            return createSchemaOf(data[key]);\r\n        }\r\n        return new Error(`Invalid array schema for ${key} at ${pointer}`);\r\n    },\r\n    object: (core, key, schema, data, pointer) => {\r\n        if (Array.isArray(schema.oneOf)) {\r\n            // update current schema\r\n            const oneOfSchema = core.resolveOneOf(data, schema, pointer);\r\n            // resolveOneOf does currently not apply merge with base schema\r\n            schema = merge(schema, oneOfSchema);\r\n            if (isJSONError(schema)) {\r\n                return schema;\r\n            }\r\n        }\r\n        if (Array.isArray(schema.anyOf)) {\r\n            // update current schema\r\n            schema = core.resolveAnyOf(data, schema, pointer);\r\n            if (isJSONError(schema)) {\r\n                return schema;\r\n            }\r\n        }\r\n        if (Array.isArray(schema.allOf)) {\r\n            // update current schema\r\n            schema = core.resolveAllOf(data, schema, pointer);\r\n            if (isJSONError(schema)) {\r\n                return schema;\r\n            }\r\n        }\r\n        let targetSchema;\r\n        // step into object-properties\r\n        if (schema.properties && schema.properties[key] !== undefined) {\r\n            // @todo patternProperties also validate properties\r\n            targetSchema = core.resolveRef(schema.properties[key]);\r\n            if (isJSONError(targetSchema)) {\r\n                return targetSchema;\r\n            }\r\n            // check if there is a oneOf selection, which must be resolved\r\n            if (targetSchema && Array.isArray(targetSchema.oneOf)) {\r\n                // @special case: this is a mix of a schema and optional definitions\r\n                // we resolve the schema here and add the original schema to `oneOfSchema`\r\n                let resolvedSchema = core.resolveOneOf(data[key], targetSchema, `${pointer}/${key}`);\r\n                const oneOfIndex = targetSchema.oneOf.findIndex((s) => s === resolvedSchema);\r\n                resolvedSchema = JSON.parse(JSON.stringify(resolvedSchema));\r\n                resolvedSchema.variableSchema = true;\r\n                resolvedSchema.oneOfIndex = oneOfIndex;\r\n                resolvedSchema.oneOfSchema = targetSchema;\r\n                return resolvedSchema;\r\n            }\r\n            // resolved schema or error\r\n            if (targetSchema) {\r\n                return targetSchema;\r\n            }\r\n        }\r\n        // @draft <= 07\r\n        const { dependencies } = schema;\r\n        if (getTypeOf(dependencies) === \"object\") {\r\n            const dependentProperties = Object.keys(dependencies).filter((propertyName) => \r\n            // data[propertyName] !== undefined &&\r\n            getTypeOf(dependencies[propertyName]) === \"object\");\r\n            for (let i = 0, l = dependentProperties.length; i < l; i += 1) {\r\n                const dependentProperty = dependentProperties[i];\r\n                const schema = step(core, key, dependencies[dependentProperty], data, `${pointer}/${dependentProperty}`);\r\n                if (!isJSONError(schema)) {\r\n                    return schema;\r\n                }\r\n            }\r\n        }\r\n        // @draft >= 07\r\n        if (schema.if && (schema.then || schema.else)) {\r\n            // console.log(\"test if-then-else\");\r\n            const isValid = core.isValid(data, schema.if);\r\n            if (isValid && schema.then) {\r\n                const resolvedThen = step(core, key, schema.then, data, pointer);\r\n                if (typeof resolvedThen.type === \"string\" && resolvedThen.type !== \"error\") {\r\n                    return resolvedThen;\r\n                }\r\n            }\r\n            if (!isValid && schema.else) {\r\n                const resolvedElse = step(core, key, schema.else, data, pointer);\r\n                if (typeof resolvedElse.type === \"string\" && resolvedElse.type !== \"error\") {\r\n                    return resolvedElse;\r\n                }\r\n            }\r\n        }\r\n        // find matching property key\r\n        if (getTypeOf(schema.patternProperties) === \"object\") {\r\n            let regex;\r\n            const patterns = Object.keys(schema.patternProperties);\r\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\r\n                regex = new RegExp(patterns[i]);\r\n                if (regex.test(key)) {\r\n                    return schema.patternProperties[patterns[i]];\r\n                }\r\n            }\r\n        }\r\n        if (getTypeOf(schema.additionalProperties) === \"object\") {\r\n            return schema.additionalProperties;\r\n        }\r\n        if (schema.additionalProperties === true) {\r\n            return createSchemaOf(data[key]);\r\n        }\r\n        return errors.unknownPropertyError({\r\n            property: key,\r\n            value: data,\r\n            // pointer: `${pointer}/${key}`,\r\n            pointer: `${pointer}`\r\n        });\r\n    }\r\n};\r\n/**\r\n * Returns the json-schema of the given object property or array item.\r\n * e.g. it steps by one key into the data\r\n *\r\n *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\r\n *  returns the correct schema.\r\n *\r\n * @param  core      - validator\r\n * @param  key       - property-name or array-index\r\n * @param  schema    - json schema of current data\r\n * @param  data      - parent of key\r\n * @param  [pointer] - pointer to schema and data (parent of key)\r\n * @return Schema or Error if failed resolving key\r\n */\r\nexport default function step(core, key, schema, data, pointer = \"#\") {\r\n    // @draft >= 4 ?\r\n    if (Array.isArray(schema.type)) {\r\n        const dataType = getTypeOf(data);\r\n        if (schema.type.includes(dataType)) {\r\n            // @ts-ignore\r\n            return stepType[dataType](core, `${key}`, schema, data, pointer);\r\n        }\r\n        return core.errors.typeError({\r\n            value: data,\r\n            pointer,\r\n            expected: schema.type,\r\n            received: dataType\r\n        });\r\n    }\r\n    const expectedType = schema.type || getTypeOf(data);\r\n    // @ts-ignore\r\n    const stepFunction = stepType[expectedType];\r\n    if (stepFunction) {\r\n        return stepFunction(core, `${key}`, schema, data, pointer);\r\n    }\r\n    return new Error(`Unsupported schema type ${schema.type} for key ${key}`);\r\n}\r\n", "/**\r\n * @todo: type is also a keyword, as is properties, items, etc\r\n *\r\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-core.html#rfc.section.4.2)\r\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\r\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\r\n */\r\nconst validationType = {\r\n    array: (core, schema, value, pointer) => core.typeKeywords.array\r\n        .filter((key) => schema && schema[key] != null)\r\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\r\n    object: (core, schema, value, pointer) => core.typeKeywords.object\r\n        .filter((key) => schema && schema[key] != null)\r\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\r\n    string: (core, schema, value, pointer) => core.typeKeywords.string\r\n        .filter((key) => schema && schema[key] != null)\r\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\r\n    integer: (core, schema, value, pointer) => core.typeKeywords.number\r\n        .filter((key) => schema && schema[key] != null)\r\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\r\n    number: (core, schema, value, pointer) => core.typeKeywords.number\r\n        .filter((key) => schema && schema[key] != null)\r\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\r\n    boolean: (core, schema, value, pointer) => core.typeKeywords.boolean\r\n        .filter((key) => schema && schema[key] != null)\r\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\r\n    null: (core, schema, value, pointer) => core.typeKeywords.null\r\n        .filter((key) => schema && schema[key] != null)\r\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer))\r\n};\r\nexport default validationType;\r\n", "import getTypeOf from \"./getTypeOf\";\r\nimport { errorOrPromise } from \"./utils/filter\";\r\nimport flattenArray from \"./utils/flattenArray\";\r\nimport { isJSONError } from \"./types\";\r\nimport equal from \"fast-deep-equal\";\r\nfunction getJsonSchemaType(value, expectedType) {\r\n    const jsType = getTypeOf(value);\r\n    if (jsType === \"number\" &&\r\n        (expectedType === \"integer\" ||\r\n            (Array.isArray(expectedType) && expectedType.includes(\"integer\")))) {\r\n        return Number.isInteger(value) || isNaN(value) ? \"integer\" : \"number\";\r\n    }\r\n    return jsType;\r\n}\r\n/**\r\n * Validate data by a json schema\r\n *\r\n * @param core - validator\r\n * @param value - value to validate\r\n * @param [schema] - json schema, defaults to rootSchema\r\n * @param [pointer] - json pointer pointing to value (used for error-messages only)\r\n * @return list of errors or empty\r\n */\r\nexport default function validate(core, value, schema = core.rootSchema, pointer = \"#\") {\r\n    schema = core.resolveRef(schema);\r\n    // this is a high level v7 schema validation\r\n    if (getTypeOf(schema) === \"boolean\") {\r\n        if (schema) {\r\n            return [];\r\n        }\r\n        return [core.errors.invalidDataError({ value, pointer })];\r\n    }\r\n    if (isJSONError(schema)) {\r\n        return [schema];\r\n    }\r\n    // @draft >= 6 const\r\n    if (schema.const !== undefined) {\r\n        if (equal(schema.const, value)) {\r\n            return [];\r\n        }\r\n        return [core.errors.constError({ value, expected: schema.const, pointer })];\r\n    }\r\n    const receivedType = getJsonSchemaType(value, schema.type);\r\n    const expectedType = schema.type || receivedType;\r\n    if (receivedType !== expectedType &&\r\n        (!Array.isArray(expectedType) || !expectedType.includes(receivedType))) {\r\n        return [\r\n            core.errors.typeError({\r\n                received: receivedType,\r\n                expected: expectedType,\r\n                value,\r\n                pointer\r\n            })\r\n        ];\r\n    }\r\n    if (core.validateType[receivedType] == null) {\r\n        return [core.errors.invalidTypeError({ receivedType, pointer })];\r\n    }\r\n    const errors = flattenArray(core.validateType[receivedType](core, schema, value, pointer));\r\n    // also promises may be passed along (validateAsync)\r\n    // @ts-ignore\r\n    return errors.filter(errorOrPromise);\r\n}\r\n", "import addRemoteSchema from \"../addRemoteSchema\";\r\nimport compileSchema from \"../draft06/compile\";\r\nimport { each } from \"../each\";\r\nimport { eachSchema } from \"../eachSchema\";\r\nimport ERRORS from \"../validation/errors\";\r\nimport FORMATS from \"../validation/format\";\r\nimport getSchema from \"../getSchema\";\r\nimport getTemplate from \"../getTemplate\";\r\nimport isValid from \"../isValid\";\r\nimport KEYWORDS from \"../draft06/validation/keyword\";\r\nimport merge from \"../utils/merge\";\r\nimport resolveAllOf from \"../resolveAllOf\";\r\nimport resolveAnyOf from \"../resolveAnyOf\";\r\nimport resolveOneOf from \"../resolveOneOf.strict\";\r\nimport resolveRef from \"../resolveRef.strict\";\r\nimport createSchemaOf from \"../createSchemaOf\";\r\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\r\nimport step from \"../step\";\r\nimport TYPES from \"../draft06/validation/type\";\r\nimport validate from \"../validate\";\r\nimport { Draft } from \"../draft\";\r\nconst draft07Config = {\r\n    typeKeywords: {\r\n        array: [\"enum\", \"contains\", \"items\", \"minItems\", \"maxItems\", \"uniqueItems\", \"not\", \"if\"],\r\n        boolean: [\"enum\", \"not\"],\r\n        object: [\r\n            \"additionalProperties\",\r\n            \"dependencies\",\r\n            \"enum\",\r\n            \"format\",\r\n            \"minProperties\",\r\n            \"maxProperties\",\r\n            \"patternProperties\",\r\n            \"properties\",\r\n            \"propertyNames\",\r\n            \"required\",\r\n            \"not\",\r\n            \"oneOf\",\r\n            \"allOf\",\r\n            \"anyOf\",\r\n            \"if\"\r\n        ],\r\n        string: [\r\n            \"enum\",\r\n            \"format\",\r\n            \"maxLength\",\r\n            \"minLength\",\r\n            \"pattern\",\r\n            \"not\",\r\n            \"oneOf\",\r\n            \"allOf\",\r\n            \"anyOf\",\r\n            \"if\"\r\n        ],\r\n        number: [\r\n            \"enum\",\r\n            \"exclusiveMaximum\",\r\n            \"exclusiveMinimum\",\r\n            \"format\",\r\n            \"maximum\",\r\n            \"minimum\",\r\n            \"multipleOf\",\r\n            \"not\",\r\n            \"oneOf\",\r\n            \"allOf\",\r\n            \"anyOf\",\r\n            \"if\"\r\n        ],\r\n        null: [\"enum\", \"format\", \"not\", \"oneOf\", \"allOf\", \"anyOf\"]\r\n    },\r\n    validateKeyword: KEYWORDS,\r\n    validateType: TYPES,\r\n    validateFormat: FORMATS,\r\n    errors: ERRORS,\r\n    addRemoteSchema,\r\n    compileSchema,\r\n    createSchemaOf,\r\n    each,\r\n    eachSchema,\r\n    getChildSchemaSelection,\r\n    getSchema,\r\n    getTemplate,\r\n    isValid,\r\n    resolveAllOf,\r\n    resolveAnyOf,\r\n    resolveOneOf,\r\n    resolveRef,\r\n    step,\r\n    validate\r\n};\r\nclass Draft07 extends Draft {\r\n    constructor(schema, config = {}) {\r\n        super(merge(draft07Config, config), schema);\r\n    }\r\n}\r\nexport { Draft07, draft07Config };\r\n", "import merge from \"../utils/merge\";\r\nimport resolveOneOf from \"../resolveOneOf.fuzzy\";\r\nimport resolveRef from \"../resolveRef.merge\";\r\nimport { Draft } from \"../draft\";\r\nimport { draft07Config } from \"../draft07\";\r\nconst draftJsonEditorConfig = {\r\n    ...draft07Config,\r\n    resolveOneOf,\r\n    resolveRef\r\n};\r\nclass JsonEditor extends Draft {\r\n    constructor(schema, config = {}) {\r\n        super(merge(draftJsonEditorConfig, config), schema);\r\n    }\r\n}\r\nexport { JsonEditor, draftJsonEditorConfig };\r\n", "import getSchema from \"./getSchema\";\r\nimport { JsonEditor as Core } from \"./jsoneditor\";\r\nimport gp from \"@sagold/json-pointer\";\r\nimport copy from \"./utils/copy\";\r\nexport default class SchemaService {\r\n    constructor(schema, data) {\r\n        this.core = new Core(schema);\r\n        this.schema = schema;\r\n        this.data = data;\r\n        this.cache = {};\r\n    }\r\n    updateData(data) {\r\n        this.data = data;\r\n        this.cache = {};\r\n    }\r\n    updateSchema(schema) {\r\n        this.schema = schema;\r\n        this.core.setSchema(schema);\r\n        this.cache = {};\r\n    }\r\n    get(pointer, data) {\r\n        if (data) {\r\n            // possibly separate entry point\r\n            const schema = getSchema(this.core, pointer, data, this.schema);\r\n            return copy(schema);\r\n        }\r\n        if (pointer === \"#\") {\r\n            // root\r\n            return this.schema;\r\n        }\r\n        if (this.cache[pointer]) {\r\n            // return cached result\r\n            return this.cache[pointer];\r\n        }\r\n        const parentPointer = gp.join(pointer, \"..\");\r\n        let parentSchema = this.cache[parentPointer];\r\n        if (parentSchema == null) {\r\n            // store parent (major performance improvement if its within oneof)\r\n            parentSchema = getSchema(this.core, parentPointer, this.data, this.schema);\r\n            if (parentSchema.variableSchema !== true) {\r\n                this.cache[parentPointer] = copy(parentSchema);\r\n            }\r\n        }\r\n        // step from parent to child\r\n        const key = gp.split(pointer).pop();\r\n        let schema = getSchema(this.core, key, gp.get(this.data, parentPointer), this.cache[parentPointer]);\r\n        schema = copy(schema);\r\n        if (schema.variableSchema !== true) {\r\n            this.cache[pointer] = schema;\r\n        }\r\n        return schema;\r\n    }\r\n}\r\n", "import { errorsOnly } from \"./utils/filter\";\r\nimport flattenArray from \"./utils/flattenArray\";\r\nimport { isJSONError } from \"./types\";\r\nfunction createErrorNotification(onError) {\r\n    return function notifyError(error) {\r\n        if (Array.isArray(error)) {\r\n            error = flattenArray(error);\r\n            error.forEach(notifyError);\r\n            return error;\r\n        }\r\n        if (isJSONError(error)) {\r\n            onError(error);\r\n        }\r\n        return error;\r\n    };\r\n}\r\n/**\r\n * @async\r\n * Validate data by a json schema\r\n *\r\n * @param core - validator\r\n * @param value - value to validate\r\n * @param options\r\n * @param options.schema - json schema to use, defaults to core.rootSchema\r\n * @param options.pointer - json pointer pointing to current value. Used in error reports\r\n * @param options.onError   - will be called for each error as soon as it is resolved\r\n * @return list of errors or empty\r\n */\r\nexport default function validateAsync(core, value, options) {\r\n    const { schema, pointer, onError } = { schema: core.rootSchema, pointer: \"#\", ...options };\r\n    let errors = core.validate(value, schema, pointer);\r\n    if (onError) {\r\n        errors = flattenArray(errors);\r\n        const notifyError = createErrorNotification(onError);\r\n        for (let i = 0; i < errors.length; i += 1) {\r\n            if (errors[i] instanceof Promise) {\r\n                errors[i].then(notifyError);\r\n            }\r\n            else if (isJSONError(errors[i])) {\r\n                onError(errors[i]);\r\n            }\r\n        }\r\n    }\r\n    return Promise.all(errors)\r\n        .then(flattenArray)\r\n        .then((resolvedErrors) => resolvedErrors.filter(errorsOnly))\r\n        .catch((e) => {\r\n        console.log(\"Failed resolving promises\", e.message);\r\n        console.log(e.stack);\r\n        throw e;\r\n    });\r\n}\r\n", "/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\r\nimport { eachSchema } from \"../eachSchema\";\r\nimport joinScope from \"./joinScope\";\r\nimport getRef from \"./getRef\";\r\nimport { get } from \"@sagold/json-pointer\";\r\nconst COMPILED = \"__compiled\";\r\nconst COMPILED_REF = \"__ref\";\r\nconst GET_REF = \"getRef\";\r\nconst GET_ROOT = \"getRoot\";\r\nconst suffixes = /(#|\\/)+$/g;\r\n/**\r\n * compiles the input root schema for `$ref` resolution and returns it again\r\n * @attention this modifies input schema but maintains data-structure and thus returns\r\n * the same object with JSON.stringify\r\n *\r\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\r\n * this resolves a $ref target to a valid schema (for a valid $ref)\r\n *\r\n * @param draft\r\n * @param schemaToCompile - json-schema to compile\r\n * @param [rootSchema] - compiled root json-schema to use for definitions resolution\r\n * @param [force] = false - force compile json-schema\r\n * @return compiled input json-schema\r\n */\r\nexport default function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\r\n    if (!schemaToCompile || schemaToCompile[COMPILED] !== undefined) {\r\n        return schemaToCompile;\r\n    }\r\n    const context = { ids: {}, remotes: draft.remotes };\r\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\r\n    const compiledSchema = JSON.parse(rootSchemaAsString);\r\n    // flag this schema as compiled\r\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\r\n    // add getRef-helper to this object\r\n    Object.defineProperty(compiledSchema, GET_REF, {\r\n        enumerable: false,\r\n        value: getRef.bind(null, context, compiledSchema)\r\n    });\r\n    // bail early, when no $refs are defined\r\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\r\n        return compiledSchema;\r\n    }\r\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\r\n    if (schemaToCompile !== rootSchema) {\r\n        Object.defineProperty(compiledSchema, \"definitions\", {\r\n            enumerable: false,\r\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, schemaToCompile.definitions, schemaToCompile.$defs)\r\n        });\r\n    }\r\n    const scopes = {};\r\n    const getRoot = () => compiledSchema;\r\n    eachSchema(compiledSchema, (schema, pointer) => {\r\n        var _a;\r\n        if (schema.id) {\r\n            // if this is a schema being merged on root object, we cannot override\r\n            // parents locations, but must reuse it\r\n            if (schema.id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\r\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\r\n                const parentSchema = get(compiledSchema, parentPointer);\r\n                schema.id = (_a = parentSchema.id) !== null && _a !== void 0 ? _a : schema.id;\r\n            }\r\n            context.ids[schema.id.replace(suffixes, \"\")] = pointer;\r\n        }\r\n        // build up scopes and add them to $ref-resolution map\r\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\r\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\r\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\r\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\r\n        const scope = joinScope(previousScope, schema.id);\r\n        scopes[pointer] = scope;\r\n        if (context.ids[scope] == null) {\r\n            context.ids[scope] = pointer;\r\n        }\r\n        if (schema.$ref && !schema[COMPILED_REF]) {\r\n            Object.defineProperty(schema, COMPILED_REF, {\r\n                enumerable: false,\r\n                value: joinScope(scope, schema.$ref)\r\n            });\r\n            // @todo currently not used:\r\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\r\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\r\n        }\r\n    });\r\n    // console.log(JSON.stringify(context.ids, null, 2));\r\n    return compiledSchema;\r\n}\r\n", "import compile from \"./compile\";\r\nexport default compile;\r\n", "/**\r\n * @todo: type is also a keyword, as is properties, items, etc\r\n *\r\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-core.html#rfc.section.4.2)\r\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\r\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\r\n */\r\nconst typeValidators = {\r\n    array: (core, schema, value, pointer) => core.typeKeywords.array\r\n        .filter(key => schema && schema[key] != null)\r\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\r\n    object: (core, schema, value, pointer) => core.typeKeywords.object\r\n        .filter(key => schema && schema[key] != null)\r\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\r\n    string: (core, schema, value, pointer) => core.typeKeywords.string\r\n        .filter(key => schema && schema[key] != null)\r\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\r\n    integer: (core, schema, value, pointer) => core.typeKeywords.number\r\n        .filter(key => schema && schema[key] != null)\r\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\r\n    number: (core, schema, value, pointer) => core.typeKeywords.number\r\n        .filter(key => schema && schema[key] != null)\r\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\r\n    \"boolean\": (core, schema, value, pointer) => core.typeKeywords.boolean\r\n        .filter(key => schema && schema[key] != null)\r\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\r\n    \"null\": (core, schema, value, pointer) => core.typeKeywords.null\r\n        .filter(key => schema && schema[key] != null)\r\n        .map(key => core.validateKeyword[key](core, schema, value, pointer))\r\n};\r\nexport default typeValidators;\r\n", "import addRemoteSchema from \"../addRemoteSchema\";\r\nimport compileSchema from \"../compileSchema\";\r\nimport { each } from \"../each\";\r\nimport { eachSchema } from \"../eachSchema\";\r\nimport ERRORS from \"../validation/errors\";\r\nimport FORMATS from \"../validation/format\";\r\nimport getSchema from \"../getSchema\";\r\nimport getTemplate from \"../getTemplate\";\r\nimport isValid from \"../isValid\";\r\nimport KEYWORDS from \"../validation/keyword\";\r\nimport merge from \"../utils/merge\";\r\nimport resolveAllOf from \"../resolveAllOf\";\r\nimport resolveAnyOf from \"../resolveAnyOf\";\r\nimport resolveOneOf from \"../resolveOneOf.strict\";\r\nimport resolveRef from \"../resolveRef.strict\";\r\nimport step from \"../step\";\r\nimport createSchemaOf from \"../createSchemaOf\";\r\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\r\nimport TYPES from \"../validation/type\";\r\nimport validate from \"../validate\";\r\nimport { Draft } from \"../draft\";\r\nconst draft04Config = {\r\n    typeKeywords: {\r\n        array: [\"enum\", \"items\", \"minItems\", \"maxItems\", \"uniqueItems\", \"not\"],\r\n        boolean: [\"enum\", \"not\"],\r\n        object: [\r\n            \"additionalProperties\",\r\n            \"dependencies\",\r\n            \"enum\",\r\n            \"format\",\r\n            \"minProperties\",\r\n            \"maxProperties\",\r\n            \"patternProperties\",\r\n            \"properties\",\r\n            \"required\",\r\n            \"not\",\r\n            \"oneOf\",\r\n            \"allOf\",\r\n            \"anyOf\"\r\n        ],\r\n        string: [\r\n            \"enum\",\r\n            \"format\",\r\n            \"maxLength\",\r\n            \"minLength\",\r\n            \"pattern\",\r\n            \"not\",\r\n            \"oneOf\",\r\n            \"allOf\",\r\n            \"anyOf\"\r\n        ],\r\n        number: [\r\n            \"enum\",\r\n            \"format\",\r\n            \"maximum\",\r\n            \"minimum\",\r\n            \"multipleOf\",\r\n            \"not\",\r\n            \"oneOf\",\r\n            \"allOf\",\r\n            \"anyOf\"\r\n        ],\r\n        null: [\"enum\", \"format\", \"not\", \"oneOf\", \"allOf\", \"anyOf\"]\r\n    },\r\n    validateKeyword: KEYWORDS,\r\n    validateType: TYPES,\r\n    validateFormat: FORMATS,\r\n    errors: ERRORS,\r\n    addRemoteSchema,\r\n    compileSchema,\r\n    createSchemaOf,\r\n    each,\r\n    eachSchema,\r\n    getChildSchemaSelection,\r\n    getSchema,\r\n    getTemplate,\r\n    isValid,\r\n    resolveAllOf,\r\n    resolveAnyOf,\r\n    resolveOneOf,\r\n    resolveRef,\r\n    step,\r\n    validate\r\n};\r\nclass Draft04 extends Draft {\r\n    constructor(schema, config = {}) {\r\n        super(merge(draft04Config, config), schema);\r\n    }\r\n}\r\nexport { Draft04, draft04Config };\r\n", "import addRemoteSchema from \"../addRemoteSchema\";\r\nimport compileSchema from \"../draft06/compile\";\r\nimport { each } from \"../each\";\r\nimport { eachSchema } from \"../eachSchema\";\r\nimport ERRORS from \"../validation/errors\";\r\nimport FORMATS from \"../validation/format\";\r\nimport getSchema from \"../getSchema\";\r\nimport getTemplate from \"../getTemplate\";\r\nimport isValid from \"../isValid\";\r\nimport KEYWORDS from \"../draft06/validation/keyword\";\r\nimport merge from \"../utils/merge\";\r\nimport resolveAllOf from \"../resolveAllOf\";\r\nimport resolveAnyOf from \"../resolveAnyOf\";\r\nimport resolveOneOf from \"../resolveOneOf.strict\";\r\nimport resolveRef from \"../resolveRef.strict\";\r\nimport createSchemaOf from \"../createSchemaOf\";\r\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\r\nimport step from \"../step\";\r\nimport TYPES from \"../draft06/validation/type\";\r\nimport validate from \"../validate\";\r\nimport { Draft } from \"../draft\";\r\nconst draft06Config = {\r\n    typeKeywords: {\r\n        array: [\"enum\", \"contains\", \"items\", \"minItems\", \"maxItems\", \"uniqueItems\", \"not\", \"if\"],\r\n        boolean: [\"enum\", \"not\"],\r\n        object: [\r\n            \"additionalProperties\",\r\n            \"dependencies\",\r\n            \"enum\",\r\n            \"format\",\r\n            \"minProperties\",\r\n            \"maxProperties\",\r\n            \"patternProperties\",\r\n            \"properties\",\r\n            \"propertyNames\",\r\n            \"required\",\r\n            \"not\",\r\n            \"oneOf\",\r\n            \"allOf\",\r\n            \"anyOf\",\r\n            \"if\"\r\n        ],\r\n        string: [\r\n            \"enum\",\r\n            \"format\",\r\n            \"maxLength\",\r\n            \"minLength\",\r\n            \"pattern\",\r\n            \"not\",\r\n            \"oneOf\",\r\n            \"allOf\",\r\n            \"anyOf\",\r\n            \"if\"\r\n        ],\r\n        number: [\r\n            \"enum\",\r\n            \"exclusiveMaximum\",\r\n            \"exclusiveMinimum\",\r\n            \"format\",\r\n            \"maximum\",\r\n            \"minimum\",\r\n            \"multipleOf\",\r\n            \"not\",\r\n            \"oneOf\",\r\n            \"allOf\",\r\n            \"anyOf\",\r\n            \"if\"\r\n        ],\r\n        null: [\"enum\", \"format\", \"not\", \"oneOf\", \"allOf\", \"anyOf\"]\r\n    },\r\n    validateKeyword: KEYWORDS,\r\n    validateType: TYPES,\r\n    validateFormat: FORMATS,\r\n    errors: ERRORS,\r\n    addRemoteSchema,\r\n    compileSchema,\r\n    createSchemaOf,\r\n    each,\r\n    eachSchema,\r\n    getChildSchemaSelection,\r\n    getSchema,\r\n    getTemplate,\r\n    isValid,\r\n    resolveAllOf,\r\n    resolveAnyOf,\r\n    resolveOneOf,\r\n    resolveRef,\r\n    step,\r\n    validate\r\n};\r\nclass Draft06 extends Draft {\r\n    constructor(schema, config = {}) {\r\n        super(merge(draft06Config, config), schema);\r\n    }\r\n}\r\nexport { Draft06, draft06Config };\r\n", "import { createError, createCustomError } from \"./lib/utils/createCustomError\";\r\nimport getTypeOf from \"./lib/getTypeOf\";\r\nimport resolveOneOf from \"./lib/resolveOneOf.strict\";\r\nimport resolveAllOf from \"./lib/resolveAllOf\";\r\nimport resolveOneOfFuzzy from \"./lib/resolveOneOf.fuzzy\";\r\nimport resolveRef from \"./lib/resolveRef.strict\";\r\nimport resolveRefMerge from \"./lib/resolveRef.merge\";\r\nimport SchemaService from \"./lib/SchemaService\";\r\nimport settings from \"./lib/config/settings\";\r\nimport strings from \"./lib/config/strings\";\r\nimport validateAsync from \"./lib/validateAsync\";\r\nimport render from \"./lib/utils/render\";\r\nimport { Draft } from \"./lib/draft\";\r\nimport { Draft04, draft04Config } from \"./lib/draft04\";\r\nimport { Draft06, draft06Config } from \"./lib/draft06\";\r\nimport { Draft07, draft07Config } from \"./lib/draft07\";\r\nimport { JsonEditor, draftJsonEditorConfig } from \"./lib/jsoneditor\";\r\nimport { isJSONError } from \"./lib/types\";\r\nconst config = { strings };\r\nexport { config, Draft, Draft04, // core implementing draft04 specs\r\ndraft04Config, // config implementing draft04 specs\r\nDraft06, // core implementing draft06 specs\r\ndraft06Config, // config implementing draft06 specs\r\nDraft07, // core implementing draft07 specs\r\ndraft07Config, // config implementing draft07 specs\r\nJsonEditor, // adjusted core of draft04 to better support the json-editor\r\ndraftJsonEditorConfig, // adjusted config of draft04 to better support the json-editor\r\ncreateError, createCustomError, getTypeOf, // returns the javascript datatype\r\nisJSONError, render, resolveAllOf, resolveRef, resolveRefMerge, resolveOneOf, resolveOneOfFuzzy, settings, SchemaService, validateAsync // async validation of data by a schema\r\n };\r\n"],
  "mappings": "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",
  "names": ["require_cjs", "__commonJSMin", "exports", "module", "isMergeableObject", "value", "isNonNullObject", "isSpecial", "stringValue", "isReactElement", "canUseSymbol", "REACT_ELEMENT_TYPE", "emptyTarget", "val", "cloneUnlessOtherwiseSpecified", "options", "deepmerge", "defaultArrayMerge", "target", "source", "element", "getMergeFunction", "key", "customMerge", "getEnumerableOwnPropertySymbols", "symbol", "getKeys", "propertyIsOnObject", "object", "property", "propertyIsUnsafe", "mergeObject", "destination", "sourceIsArray", "targetIsArray", "sourceAndTargetTypesMatch", "array", "prev", "next", "deepmerge_1", "require_jsonPointer", "__commonJSMin", "exports", "module", "e", "t", "n", "r", "x", "c", "_", "v", "j", "y", "o", "i", "l", "u", "f", "p", "a", "d", "g", "m", "h", "b", "A", "P", "O", "require_TokenError", "__commonJSMin", "exports", "TokenError", "message", "token", "require_Parser", "__commonJSMin", "txt", "expr", "result", "str", "token", "c", "start", "errors", "err", "tok", "name", "postDecoration", "preDecoration", "postDecorationText", "preDecorationText", "out", "parser", "parsed", "re", "localRules", "x", "i", "indexOnChildren", "grammarRules", "options", "neededRules", "rule", "parsedName", "error", "option", "ruleName", "target", "rest", "e", "phases", "pinned", "tmp", "tmpTxt", "position", "allOptional", "foundSomething", "localTarget", "got", "foundAtLeastOne", "WS", "recoverableToken", "recursion", "printable", "require_W3CEBNF", "__commonJSMin", "exports", "Parser_1", "BNF", "preDecorationRE", "decorationRE", "subExpressionRE", "getBNFRule", "name", "parser", "decoration", "decorationText", "isLonelyRule", "getBNFBody", "rule", "getBNFChoice", "rules", "x", "emit", "acumulator", "l", "recover", "subitems", "restar", "total", "resta", "convertRegex", "txt", "getSubItems", "tmpRules", "seq", "parentName", "anterior", "bnfSeq", "i", "preDecoration", "createRule", "newRule", "token", "bnf", "s", "getRules", "source", "ast", "Transform", "subParser", "Parser", "options", "require_valid_url", "__commonJSMin", "exports", "module", "is_iri", "is_http_iri", "is_https_iri", "is_web_iri", "splitUri", "uri", "splitted", "value", "scheme", "authority", "path", "query", "fragment", "out", "allowHttps", "port", "require_fast_deep_equal", "__commonJSMin", "exports", "module", "equal", "a", "b", "length", "keys", "key", "strings_default", "render", "template", "data", "match", "__", "keyword", "data", "fallback", "template", "strings_default", "render", "dashCase", "text", "createError", "name", "data", "__", "createCustomError", "toString", "getTypeOf", "value", "type", "isJSONError", "error", "isPromise", "obj", "errorOrPromise", "error", "isJSONError", "errorsOnly", "flattenArray", "list", "result", "i", "item", "settings_default", "DECLARATOR_ONEOF", "settings_default", "resolveOneOf", "core", "data", "schema", "pointer", "errors", "oneOfProperty", "oneOfValue", "i", "one", "oneOfPropertySchema", "isJSONError", "result", "flattenArray", "errorOrPromise", "matches", "copy_default", "value", "import_deepmerge", "overwriteMerge", "destinationArray", "sourceArray", "merge_default", "a", "b", "deepmerge", "mergeUniqueItems", "all", "item", "pos", "mergeArraysUnique", "resolveSchema", "draft", "schemaToResolve", "data", "_a", "schema", "__spreadValues", "isValid", "resolveAllOf", "pointer", "mergedSchema", "copy_default", "i", "allOfSchema", "mergeArraysUnique", "DECLARATOR_ONEOF", "settings_default", "fuzzyObjectValue", "core", "one", "data", "pointer", "value", "keys", "i", "key", "resolveOneOf", "schema", "errors", "oneOfProperty", "oneOfValue", "oneOfPropertySchema", "isJSONError", "result", "flattenArray", "errorOrPromise", "matches", "getTypeOf", "schemaOfItem", "fuzzyGreatest", "fuzzyValue", "resolveRef", "schema", "rootSchema", "resolveRefMerge", "schema", "rootSchema", "resolvedSchema", "mergedSchema", "import_json_pointer", "emptyObject", "getSchema", "draft", "pointer", "data", "schema", "frags", "gp", "_get", "key", "isJSONError", "Draft", "config", "schema", "rootSchema", "url", "_a", "data", "callback", "pointer", "property", "opts", "key", "addRemoteSchema", "draft", "url", "schema", "import_json_pointer", "import_json_pointer", "import_W3CEBNF", "propertyRegex", "jsonQueryGrammar", "parser", "EBNF", "jsonQueryGrammar", "parse", "query", "join", "a", "b", "toString", "rContainer", "isContainer", "v", "getTypeOf", "nodeAsRegex", "node", "forEach", "parent", "callback", "key", "getKeys", "value", "index", "cache", "entry", "prop", "expand", "result", "childEntry", "regex", "select", "checkedTyped", "valid", "or", "expr", "isValid", "cmp", "test", "expressionMatches", "valueString", "collect", "func", "input", "node", "pointer", "result", "i", "l", "reduce", "output", "query", "data", "ast", "expand", "select", "runPatternOnce", "inputSet", "resultingSet", "workingSet", "runNode", "getIterationCount", "quantifier", "count", "pattern", "iterationCount", "skip", "n", "cache", "run", "returnTypes", "map", "e", "ReturnType", "get", "data", "queryString", "returnType", "ast", "parse", "result", "run", "r", "skip", "buildPath", "node", "path", "n", "split", "queryString", "ast", "parse", "cp", "v", "toString", "getType", "isProperty", "propertyRegex", "ignoreTypes", "isArray", "arrayHasIndex", "isEscaped", "isArrayProp", "convertToIndex", "index", "removeEscape", "property", "insert", "array", "value", "select", "workingSet", "query", "nextSet", "d", "get", "ReturnType", "addToArray", "result", "force", "target", "i", "set", "arrayIndex", "create", "keyIsArray", "o", "r", "container", "InsertMode", "data", "queryString", "path", "split", "arrayWithoutIndex", "nextKey", "insertArray", "targetValue", "unescapedProp", "import_json_pointer", "Types", "types_default", "isObject", "value", "typeKeywords", "types_default", "id", "hasOwnProperty", "getTypeId", "schema", "ids", "type", "i", "l", "keyword", "isObject", "value", "getTypeDefs", "schema", "defs", "id", "getTypeId", "type", "l", "types_default", "query", "get", "key", "parent", "pointer", "gp", "isObject", "value", "nextTypeDefs", "schema", "pointer", "getTypeDefs", "next", "gp", "eachDefinition", "walk", "key", "defs", "defId", "eachSchema", "callback", "defschema", "schemaPointer", "suffixes", "trailingHash", "isDomain", "trailingFragments", "idAndPointer", "joinScope", "previous", "id", "import_json_pointer", "suffixes", "emptyValues", "splitRef", "$ref", "result", "suffixes", "isObject", "val", "getTypeOf", "getRef", "context", "rootSchema", "$ref", "schema", "$remote", "fragments", "splitRef", "base", "import_json_pointer", "COMPILED", "COMPILED_REF", "GET_REF", "GET_ROOT", "suffixes", "compileSchema", "draft", "schemaToCompile", "rootSchema", "force", "context", "rootSchemaAsString", "compiledSchema", "getRef", "scopes", "getRoot", "eachSchema", "schema", "pointer", "_a", "parentPointer", "parentSchema", "previousPointer", "previousScope", "scope", "joinScope", "each", "core", "data", "callback", "schema", "pointer", "dataType", "getTypeOf", "key", "nextSchema", "next", "errors", "createCustomError", "errors_default", "import_valid_url", "isValidDateTime", "isValidIPV4", "isValidIPV6", "isValidHostname", "matchDate", "matchTime", "DAYS", "isValidJSONPointer", "isValidRelativeJSONPointer", "isValidURIRef", "isValidURITemplate", "formatValidators", "core", "schema", "value", "pointer", "matches", "errors_default", "year", "month", "day", "isLeapYear", "name", "host", "rest", "part", "e", "hour", "minute", "second", "timeZone", "validUrl", "format_default", "isEmpty", "v", "getTypeOf", "defaultOptions", "cache", "shouldResolveRef", "schema", "pointer", "$ref", "settings_default", "resolveRef", "core", "convertValue", "type", "value", "e", "createTemplateSchema", "data", "getTypeOf", "templateSchema", "copy_default", "resolvedAnyOf", "merge_default", "i", "l", "isJSONSchema", "template", "getTemplate", "_schema", "opts", "isEmpty", "__spreadProps", "__spreadValues", "resolvedSchema", "resolveOneOf", "isJSONError", "selectType", "TYPE", "types", "defaultValue", "defaultType", "dataType", "getDefault", "_a", "d", "required", "key", "isRequired", "dependency", "prop", "result", "isValid", "additionalData", "_b", "_c", "oneOfSchema", "itemCount", "one", "templateValue", "initValue", "getTemplate_default", "isValid", "core", "value", "schema", "pointer", "deepCompareStrict", "a", "b", "typeofa", "length", "aKeys", "bKeys", "k", "ucs2decode", "string", "output", "counter", "length", "value", "extra", "FPP", "settings_default", "hasOwnProperty", "hasProperty", "value", "property", "KeywordValidation", "core", "schema", "pointer", "getTypeOf", "errors", "receivedProperties", "prop", "expectedProperties", "patterns", "pattern", "i", "l", "isObject", "result", "isJSONError", "subSchema", "dependencyErrors", "type", "dependency", "missingProperty", "valueStr", "itemData", "itemSchema", "itemErrors", "lengthOfString", "ucs2decode", "propertyCount", "properties", "pp", "keys", "expr", "key", "patternFound", "valErrors", "keyErrors", "item", "index", "deepCompareStrict", "keyword_default", "KeywordValidation", "__spreadProps", "__spreadValues", "keyword_default", "core", "schema", "value", "pointer", "getTypeOf", "ifErrors", "properties", "pp", "errors", "keys", "patterns", "expr", "key", "patternFound", "i", "l", "valErrors", "propertySchema", "prop", "validationResult", "resolveAnyOf", "core", "data", "schema", "pointer", "found", "mergedSchema", "copy_default", "i", "anyOfSchema", "merge_default", "errors_default", "createSchemaOf", "data", "schema", "getTypeOf", "key", "getChildSchemaSelection", "core", "property", "schema", "result", "isJSONError", "item", "stepType", "core", "key", "schema", "data", "pointer", "itemsType", "getTypeOf", "createSchemaOf", "errors_default", "oneOfSchema", "merge_default", "isJSONError", "targetSchema", "resolvedSchema", "oneOfIndex", "dependencies", "dependentProperties", "propertyName", "i", "l", "dependentProperty", "step", "isValid", "resolvedThen", "resolvedElse", "regex", "patterns", "dataType", "expectedType", "stepFunction", "validationType", "core", "schema", "value", "pointer", "key", "type_default", "import_fast_deep_equal", "getJsonSchemaType", "value", "expectedType", "jsType", "getTypeOf", "validate", "core", "schema", "pointer", "isJSONError", "equal", "receivedType", "flattenArray", "errorOrPromise", "draft07Config", "keyword_default", "type_default", "format_default", "errors_default", "addRemoteSchema", "compileSchema", "createSchemaOf", "each", "eachSchema", "getChildSchemaSelection", "getSchema", "getTemplate_default", "isValid", "resolveAllOf", "resolveAnyOf", "resolveOneOf", "resolveRef", "step", "validate", "Draft07", "Draft", "schema", "config", "merge_default", "draftJsonEditorConfig", "__spreadProps", "__spreadValues", "draft07Config", "resolveOneOf", "resolveRefMerge", "JsonEditor", "Draft", "schema", "config", "merge_default", "import_json_pointer", "SchemaService", "schema", "data", "JsonEditor", "pointer", "getSchema", "copy_default", "parentPointer", "gp", "parentSchema", "key", "createErrorNotification", "onError", "notifyError", "error", "flattenArray", "isJSONError", "validateAsync", "core", "value", "options", "schema", "pointer", "__spreadValues", "errors", "i", "resolvedErrors", "errorsOnly", "e", "import_json_pointer", "COMPILED", "COMPILED_REF", "GET_REF", "GET_ROOT", "suffixes", "compileSchema", "draft", "schemaToCompile", "rootSchema", "force", "context", "rootSchemaAsString", "compiledSchema", "getRef", "scopes", "getRoot", "eachSchema", "schema", "pointer", "_a", "parentPointer", "parentSchema", "previousPointer", "previousScope", "scope", "joinScope", "compileSchema_default", "compileSchema", "typeValidators", "core", "schema", "value", "pointer", "key", "type_default", "draft04Config", "keyword_default", "type_default", "format_default", "errors_default", "addRemoteSchema", "compileSchema_default", "createSchemaOf", "each", "eachSchema", "getChildSchemaSelection", "getSchema", "getTemplate_default", "isValid", "resolveAllOf", "resolveAnyOf", "resolveOneOf", "resolveRef", "step", "validate", "Draft04", "Draft", "schema", "config", "merge_default", "draft06Config", "keyword_default", "type_default", "format_default", "errors_default", "addRemoteSchema", "compileSchema", "createSchemaOf", "each", "eachSchema", "getChildSchemaSelection", "getSchema", "getTemplate_default", "isValid", "resolveAllOf", "resolveAnyOf", "resolveOneOf", "resolveRef", "step", "validate", "Draft06", "Draft", "schema", "config", "merge_default", "config", "strings_default"]
}
